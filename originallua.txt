-- vrmod.lua
    -- VRモジュールのコア機能とセットアップを提供

    g_VR = g_VR or {}
    local convars = vrmod.GetConvars()
    vrmod.AddCallbackedConvar("vrmod_configversion", nil, "5")

    if convars.vrmod_configversion:GetString() ~= convars.vrmod_configversion:GetDefault() then
        timer.Simple(1, function()
            for k, v in pairs(convars) do
                pcall(function() v:Revert() end)
            end
        end)
    end

    if CLIENT then
        -- クライアント側のVR変数の初期化
        g_VR.scale = 0
        g_VR.origin = Vector(0, 0, 0)
        g_VR.originAngle = Angle(0, 0, 0)
        g_VR.viewModel = nil 
        g_VR.viewModelMuzzle = nil
        g_VR.viewModelPos = Vector(0, 0, 0)
        g_VR.viewModelAng = Angle(0, 0, 0)
        g_VR.usingWorldModels = false
        g_VR.active = false
        g_VR.threePoints = false 
        g_VR.sixPoints = false 
        g_VR.tracking = {}
        g_VR.input = {}
        g_VR.changedInputs = {}
        g_VR.errorText = ""

        -- コンバーの設定
        vrmod.AddCallbackedConvar("vrmod_althead", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_autostart", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_scale", nil, "38.7")
        vrmod.AddCallbackedConvar("vrmod_heightmenu", nil, "1")
        vrmod.AddCallbackedConvar("vrmod_floatinghands", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_desktopview", nil, "3")
        vrmod.AddCallbackedConvar("vrmod_useworldmodels", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_laserpointer", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_znear", nil, "1")
        vrmod.AddCallbackedConvar("vrmod_oldcharacteryaw", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_x", nil, "-15")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_y", nil, "-1")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_z", nil, "5")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_pitch", nil, "50")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_yaw", nil, "0")
        vrmod.AddCallbackedConvar("vrmod_controlleroffset_roll", nil, "0")
        vrmod.AddCallbackedConvar(
            "vrmod_postprocess",
            nil,
            "0",
            nil,
            nil,
            nil,
            nil,
            tobool,
            function(val)
                if g_VR.view then
                    g_VR.view.dopostprocess = val
                end
            end
        )

        -- VRモードメニューの設定
        hook.Add("VRMod_Menu", "vrmod_options", function(frame)
            local form = frame.SettingsForm
            form:CheckBox("Use floating hands", "vrmod_floatinghands")
            form:CheckBox("Use weapon world models", "vrmod_useworldmodels")
            form:CheckBox("Add laser pointer to tools/weapons", "vrmod_laserpointer")
            
            local heightMenuCheck = form:CheckBox("Show height adjustment menu", "vrmod_heightmenu")
            local checkTime = 0
            function heightMenuCheck:OnChange(checked)
                if checked and SysTime() - checkTime < 0.1 then
                    VRUtilOpenHeightMenu()
                end
                checkTime = SysTime()
            end
            
            form:CheckBox("Alternative head angle manipulation method", "vrmod_althead")
            form:ControlHelp("Less precise, compatibility for jigglebones")
            form:CheckBox("Automatically start VR after map loads", "vrmod_autostart")
            form:CheckBox("Replace climbing mechanics (when available)", "vrmod_climbing")
            form:CheckBox("Replace door use mechanics (when available)", "vrmod_doors")
            form:CheckBox("Enable engine postprocessing", "vrmod_postprocess")
            
            -- デスクトップビュー設定
            local desktopViewPanel = vgui.Create("DPanel")
            desktopViewPanel:SetSize(300, 30)
            desktopViewPanel.Paint = function() end
            
            local dlabel = vgui.Create("DLabel", desktopViewPanel)
            dlabel:SetSize(100, 30)
            dlabel:SetPos(0, -3)
            dlabel:SetText("Desktop view:")
            dlabel:SetColor(Color(0, 0, 0))
            
            local desktopViewCombo = vgui.Create("DComboBox", desktopViewPanel)
            desktopViewCombo:Dock(TOP)
            desktopViewCombo:DockMargin(70, 0, 0, 5)
            desktopViewCombo:AddChoice("none")
            desktopViewCombo:AddChoice("left eye")
            desktopViewCombo:AddChoice("right eye")
            
            desktopViewCombo.OnSelect = function(self, index, value)
                convars.vrmod_desktopview:SetInt(index)
            end
            
            desktopViewCombo.Think = function(self)
                local v = convars.vrmod_desktopview:GetInt()
                if self.ConvarVal ~= v then
                    self.ConvarVal = v
                    self:ChooseOptionID(v)
                end
            end
            
            form:AddItem(desktopViewPanel)
            form:Button("Edit custom controller input actions", "vrmod_actioneditor")
            form:Button("Reset settings to default", "vrmod_reset")
            
            -- コントローラーオフセット設定
            local offsetForm = vgui.Create("DForm", form)
            offsetForm:SetName("Controller offsets")
            offsetForm:Dock(TOP)
            offsetForm:DockMargin(10, 10, 10, 0)
            offsetForm:DockPadding(0, 0, 0, 0)
            offsetForm:SetExpanded(false)
            
            local function SetupSlider(label, convar, min, max)
                local slider = offsetForm:NumSlider(label, convar, min, max, 0)
                slider.PerformLayout = function(self)
                    self.TextArea:SetWide(30)
                    self.Label:SetWide(30)
                end
                return slider
            end
            
            SetupSlider("X", "vrmod_controlleroffset_x", -30, 30)
            SetupSlider("Y", "vrmod_controlleroffset_y", -30, 30)
            SetupSlider("Z", "vrmod_controlleroffset_z", -30, 30)
            SetupSlider("Pitch", "vrmod_controlleroffset_pitch", -180, 180)
            SetupSlider("Yaw", "vrmod_controlleroffset_yaw", -180, 180)
            SetupSlider("Roll", "vrmod_controlleroffset_roll", -180, 180)
            
            local applyButton = offsetForm:Button("Apply offsets", "")
            function applyButton:OnReleased()
                g_VR.rightControllerOffsetPos = Vector(
                    convars.vrmod_controlleroffset_x:GetFloat(),
                    convars.vrmod_controlleroffset_y:GetFloat(),
                    convars.vrmod_controlleroffset_z:GetFloat()
                )
                g_VR.leftControllerOffsetPos = g_VR.rightControllerOffsetPos * Vector(1, -1, 1)
                
                g_VR.rightControllerOffsetAng = Angle(
                    convars.vrmod_controlleroffset_pitch:GetFloat(),
                    convars.vrmod_controlleroffset_yaw:GetFloat(),
                    convars.vrmod_controlleroffset_roll:GetFloat()
                )
                g_VR.leftControllerOffsetAng = g_VR.rightControllerOffsetAng
            end
        end)

        -- VRモードの起動、終了コマンドの設定
        concommand.Add("vrmod_start", function(ply, cmd, args)
            if vgui.CursorVisible() then
                print("vrmod: attempting startup when game is unpaused")
            end
            
            timer.Create("vrmod_start", 0.1, 0, function()
                if not vgui.CursorVisible() then
                    timer.Remove("vrmod_start")
                    VRUtilClientStart()
                end
            end)
        end)

        concommand.Add("vrmod_exit", function(ply, cmd, args)
            timer.Remove("vrmod_start")
            VRUtilClientExit()
        end)

        concommand.Add("vrmod_reset", function(ply, cmd, args)
            for k, v in pairs(vrmod.GetConvars()) do
                pcall(function() v:Revert() end)
            end
            hook.Call("VRMod_Reset")
        end)

        concommand.Add("vrmod_info", function(ply, cmd, args)
            print("========================================================================")
            print(string.format("| %-30s %s", "Addon Version:", vrmod.GetVersion()))
            print(string.format("| %-30s %s", "Module Version:", vrmod.GetModuleVersion()))
            print(string.format("| %-30s %s", "GMod Version:", VERSION .. ", Branch: " .. BRANCH))
            print(string.format("| %-30s %s", "Operating System:", 
                system.IsWindows() and "Windows" or 
                system.IsLinux() and "Linux" or 
                system.IsOSX() and "OSX" or "Unknown"))
            print(string.format("| %-30s %s", "Server Type:", 
                game.SinglePlayer() and "Single Player" or "Multiplayer"))
            print(string.format("| %-30s %s", "Server Name:", GetHostName()))
            print(string.format("| %-30s %s", "Server Address:", game.GetIPAddress()))
            print(string.format("| %-30s %s", "Gamemode:", GAMEMODE_NAME))
            
            -- アドオン統計情報
            local workshopCount = 0
            for k, v in ipairs(engine.GetAddons()) do
                workshopCount = workshopCount + (v.mounted and 1 or 0)
            end
            
            local _, folders = file.Find("addons/*", "GAME")
            local legacyBlacklist = {
                checkers = true, chess = true, common = true,
                go = true, hearts = true, spades = true
            }
            
            local legacyCount = 0
            for k, v in ipairs(folders) do
                legacyCount = legacyCount + (legacyBlacklist[v] == nil and 1 or 0)
            end
            
            print(string.format("| %-30s %s", "Workshop Addons:", workshopCount))
            print(string.format("| %-30s %s", "Legacy Addons:", legacyCount))
            print("|")
            
            -- ファイル情報出力
            local function PrintFileInfo(path)
                local files, folders = file.Find(path .. "/*", "GAME")
                for k, v in ipairs(folders) do
                    PrintFileInfo(path .. "/" .. v)
                end
                for k, v in ipairs(files) do
                    print(string.format("| %-60s %X", path .. "/" .. v, 
                        util.CRC(file.Read(path .. "/" .. v, "GAME") or "")))
                end
            end
            
            PrintFileInfo("data/vrmod")
            print("|")
            PrintFileInfo("lua/bin")
            print("|")
            
            -- コンバー情報出力
            local convarNames = {}
            for k, v in pairs(convars) do
                convarNames[#convarNames + 1] = v:GetName()
            end
            
            table.sort(convarNames)
            
            for k, v in ipairs(convarNames) do
                v = GetConVar(v)
                print(string.format("| %-30s %-20s %s", v:GetName(), v:GetString(), 
                    v:GetString() == v:GetDefault() and "" or "*"))
            end
            
            print("========================================================================")
        end)

        -- モジュールのロード
        local moduleLoaded = false
        g_VR.moduleVersion = 0
        
        if file.Exists("lua/bin/gmcl_vrmod_win32.dll", "GAME") then
            local tmpVRMod = vrmod
            vrmod = {}
            
            moduleLoaded = pcall(function() require("vrmod") end)
            
            for k, v in pairs(vrmod) do
                _G["VRMOD_" .. k] = v
            end
            
            vrmod = tmpVRMod
            g_VR.moduleVersion = moduleLoaded and VRMOD_GetVersion and VRMOD_GetVersion() or 0
        end

        -- コンバーのオーバーライド
        local convarOverrides = {}
        
        local function overrideConvar(name, value)
            local cv = GetConVar(name)
            if cv then
                convarOverrides[name] = cv:GetString()
                RunConsoleCommand(name, value)
            end
        end
        
        local function restoreConvarOverrides()
            for k, v in pairs(convarOverrides) do
                RunConsoleCommand(k, v)
            end
            convarOverrides = {}
        end

        -- 天井への丸め関数
        local function pow2ceil(x)
            return math.pow(2, math.ceil(math.log(x, 2)))
        end

        -- VRクライアントの起動
        function VRUtilClientStart()
            local error = vrmod.GetStartupError()
            if error then
                print("VRMod failed to start: " .. error)
                return
            end
            
            VRMOD_Shutdown() 
            
            if VRMOD_Init() == false then
                print("vr init failed")
                return
            end
            
            -- ディスプレイ設定
            local displayInfo = VRMOD_GetDisplayInfo(1, 10)
            local rtWidth, rtHeight = displayInfo.RecommendedWidth * 2, displayInfo.RecommendedHeight
            
            if system.IsLinux() then
                rtWidth, rtHeight = math.min(4096, pow2ceil(rtWidth)), math.min(4096, pow2ceil(rtHeight)) 
            end
            
            -- テクスチャ共有設定
            VRMOD_ShareTextureBegin()
            g_VR.rt = GetRenderTarget("vrmod_rt" .. tostring(SysTime()), rtWidth, rtHeight)
            VRMOD_ShareTextureFinish()
            
            -- ディスプレイ計算
            local displayCalculations = {
                left = {},
                right = {}
            }
            
            for k, v in pairs(displayCalculations) do
                local mtx = (k == "left") and displayInfo.ProjectionLeft or displayInfo.ProjectionRight
                local xscale = mtx[1][1]
                local xoffset = mtx[1][3]
                local yscale = mtx[2][2]
                local yoffset = mtx[2][3]
                
                local tan_px = math.abs((1.0 - xoffset) / xscale)
                local tan_nx = math.abs((-1.0 - xoffset) / xscale)
                local tan_py = math.abs((1.0 - yoffset) / yscale)
                local tan_ny = math.abs((-1.0 - yoffset) / yscale)
                
                local w = tan_px + tan_nx
                local h = tan_py + tan_ny
                
                v.HorizontalFOV = math.atan(w / 2.0) * 180 / math.pi * 2
                v.AspectRatio = w / h
                v.HorizontalOffset = xoffset
                v.VerticalOffset = yoffset
            end
            
            -- テクスチャ境界設定
            local vMin = system.IsWindows() and 0 or 1
            local vMax = system.IsWindows() and 1 or 0
            
            local uMinLeft = 0.0 + displayCalculations.left.HorizontalOffset * 0.25
            local uMaxLeft = 0.5 + displayCalculations.left.HorizontalOffset * 0.25
            local vMinLeft = vMin - displayCalculations.left.VerticalOffset * 0.5
            local vMaxLeft = vMax - displayCalculations.left.VerticalOffset * 0.5
            
            local uMinRight = 0.5 + displayCalculations.right.HorizontalOffset * 0.25
            local uMaxRight = 1.0 + displayCalculations.right.HorizontalOffset * 0.25
            local vMinRight = vMin - displayCalculations.right.VerticalOffset * 0.5
            local vMaxRight = vMax - displayCalculations.right.VerticalOffset * 0.5
            
            VRMOD_SetSubmitTextureBounds(
                uMinLeft, vMinLeft, uMaxLeft, vMaxLeft, 
                uMinRight, vMinRight, uMaxRight, vMaxRight
            )
            
            local hfovLeft = displayCalculations.left.HorizontalFOV
            local hfovRight = displayCalculations.right.HorizontalFOV
            local aspectLeft = displayCalculations.left.AspectRatio
            local aspectRight = displayCalculations.right.AspectRatio
            local ipd = displayInfo.TransformRight[1][4] * 2
            local eyez = displayInfo.TransformRight[3][4]
            
            -- アクション設定
            VRMOD_SetActionManifest("vrmod/vrmod_action_manifest.txt")
            VRMOD_SetActiveActionSets("/actions/base", LocalPlayer():InVehicle() and "/actions/driving" or "/actions/main")
            VRUtilLoadCustomActions()
            
            g_VR.input, g_VR.changedInputs = VRMOD_GetActions() 
            
            -- ネットワーク初期化
            VRUtilNetworkInit()
            
            -- VR設定初期化
            g_VR.origin = LocalPlayer():GetPos()
            g_VR.scale = convars.vrmod_scale:GetFloat()
            g_VR.rightControllerOffsetPos = Vector(
                convars.vrmod_controlleroffset_x:GetFloat(),
                convars.vrmod_controlleroffset_y:GetFloat(),
                convars.vrmod_controlleroffset_z:GetFloat()
            )
            g_VR.leftControllerOffsetPos = g_VR.rightControllerOffsetPos * Vector(1, -1, 1)
            g_VR.rightControllerOffsetAng = Angle(
                convars.vrmod_controlleroffset_pitch:GetFloat(),
                convars.vrmod_controlleroffset_yaw:GetFloat(),
                convars.vrmod_controlleroffset_roll:GetFloat()
            )
            g_VR.leftControllerOffsetAng = g_VR.rightControllerOffsetAng
            
            g_VR.active = true
            
            -- コンバーオーバーライド
            overrideConvar("gmod_mcore_test", "0")
            overrideConvar("engine_no_focus_sleep", "0")
            overrideConvar("pac_suppress_frames", "0")
            overrideConvar("pac_override_fov", "1")
            
            -- カメラビュー設定
            hook.Add("CalcView", "vrutil_hook_calcview", function(ply, pos, ang, fv)
                return {
                    origin = g_VR.tracking.hmd.pos,
                    angles = g_VR.tracking.hmd.ang,
                    fov = fv
                }
            end)
            
            -- 移動の初期化
            vrmod.StartLocomotion()
            
            -- トラッキング初期化
            g_VR.tracking = {
                hmd = {
                    pos = LocalPlayer():GetPos() + Vector(0, 0, 66.8),
                    ang = Angle(),
                    vel = Vector(),
                    angvel = Angle()
                },
                pose_lefthand = {
                    pos = LocalPlayer():GetPos(),
                    ang = Angle(),
                    vel = Vector(),
                    angvel = Angle()
                },
                pose_righthand = {
                    pos = LocalPlayer():GetPos(),
                    ang = Angle(),
                    vel = Vector(),
                    angvel = Angle()
                },
            }
            
            g_VR.threePoints = true
            
            -- 手のシミュレーション
            local simulate = {
                {
                    pose = g_VR.tracking.pose_lefthand,
                    offset = Vector(0, 10, -30)
                },
                {
                    pose = g_VR.tracking.pose_righthand,
                    offset = Vector(0, -10, -30)
                },
            }
            
            for k, v in ipairs(simulate) do
                v.pose.simulatedPos = v.pose.pos
            end
            
            hook.Add("VRMod_Tracking", "simulatehands", function()
                for k, v in ipairs(simulate) do
                    if v.pose.pos == v.pose.simulatedPos then
                        v.pose.pos, v.pose.ang = LocalToWorld(
                            v.offset, 
                            Angle(90, 0, 0), 
                            g_VR.tracking.hmd.pos, 
                            Angle(0, g_VR.tracking.hmd.ang.yaw, 0)
                        )
                        v.pose.simulatedPos = v.pose.pos
                    else
                        v.pose.simulatedPos = nil
                        table.remove(simulate, k)
                    end
                end
                
                if #simulate == 0 then
                    hook.Remove("VRMod_Tracking", "simulatehands")
                end
            end)
            
            -- ビュー設定
            g_VR.view = {
                x = 0,
                y = 0,
                w = rtWidth / 2,
                h = rtHeight,
                drawmonitors = true,
                drawviewmodel = false,
                znear = convars.vrmod_znear:GetFloat(),
                dopostprocess = convars.vrmod_postprocess:GetBool()
            }
            
            -- デスクトップビュー設定
            local desktopView = convars.vrmod_desktopview:GetInt()
            local cropVerticalMargin = (1 - (ScrH() / ScrW() * (rtWidth / 2) / rtHeight)) / 2
            local cropHorizontalOffset = (desktopView == 3) and 0.5 or 0
            
            local mat_rt = CreateMaterial(
                "vrmod_mat_rt" .. tostring(SysTime()),
                "UnlitGeneric",
                {
                    ["$basetexture"] = g_VR.rt:GetName()
                }
            )
            
            local localply = LocalPlayer()
            local currentViewEnt = localply
            local pos1, ang1
            
            -- レンダリング
            hook.Add("RenderScene", "vrutil_hook_renderscene", function()
                VRMOD_SubmitSharedTexture()
                VRMOD_UpdatePosesAndActions()
                
                -- ポーズの更新
                local rawPoses = VRMOD_GetPoses()
                
                for k, v in pairs(rawPoses) do
                    g_VR.tracking[k] = g_VR.tracking[k] or {}
                    local worldPose = g_VR.tracking[k]
                    
                    worldPose.pos, worldPose.ang = LocalToWorld(
                        v.pos * g_VR.scale, 
                        v.ang, 
                        g_VR.origin, 
                        g_VR.originAngle
                    )
                    
                    worldPose.vel = LocalToWorld(
                        v.vel, 
                        Angle(0, 0, 0), 
                        Vector(0, 0, 0), 
                        g_VR.originAngle
                    ) * g_VR.scale
                    
                    worldPose.angvel = LocalToWorld(
                        Vector(v.angvel.pitch, v.angvel.yaw, v.angvel.roll), 
                        Angle(0, 0, 0), 
                        Vector(0, 0, 0), 
                        g_VR.originAngle
                    )
                    
                    if k == "pose_righthand" then
                        worldPose.pos, worldPose.ang = LocalToWorld(
                            g_VR.rightControllerOffsetPos * 0.01 * g_VR.scale, 
                            g_VR.rightControllerOffsetAng, 
                            worldPose.pos, 
                            worldPose.ang
                        )
                    elseif k == "pose_lefthand" then
                        worldPose.pos, worldPose.ang = LocalToWorld(
                            g_VR.leftControllerOffsetPos * 0.01 * g_VR.scale, 
                            g_VR.leftControllerOffsetAng, 
                            worldPose.pos, 
                            worldPose.ang
                        )
                    end
                end
                
                g_VR.sixPoints = (g_VR.tracking.pose_waist and 
                                g_VR.tracking.pose_leftfoot and 
                                g_VR.tracking.pose_rightfoot) ~= nil
                
                hook.Call("VRMod_Tracking")
                
                g_VR.input, g_VR.changedInputs = VRMOD_GetActions()
                
                for k, v in pairs(g_VR.changedInputs) do
                    hook.Call("VRMod_Input", nil, k, v)
                end
                
                -- ウィンドウフォーカスチェック
                if not system.HasFocus() or #g_VR.errorText > 0 then
                    render.Clear(0, 0, 0, 255, true, true)
                    cam.Start2D()
                    local text = not system.HasFocus() and 
                        "Please focus the game window" or g_VR.errorText
                    draw.DrawText(text, "DermaLarge", ScrW() / 2, ScrH() / 2, 
                        Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
                    cam.End2D()
                    return true
                end
                
                -- ネットワーク更新
                local netFrame = VRUtilNetUpdateLocalPly()
                
                -- ビューモデル更新
                if g_VR.currentvmi then
                    local pos, ang = LocalToWorld(
                        g_VR.currentvmi.offsetPos, 
                        g_VR.currentvmi.offsetAng, 
                        g_VR.tracking.pose_righthand.pos, 
                        g_VR.tracking.pose_righthand.ang
                    )
                    g_VR.viewModelPos = pos
                    g_VR.viewModelAng = ang
                end
                
                if IsValid(g_VR.viewModel) then
                    if not g_VR.usingWorldModels then
                        g_VR.viewModel:SetPos(g_VR.viewModelPos)
                        g_VR.viewModel:SetAngles(g_VR.viewModelAng)
                        g_VR.viewModel:SetupBones()
                        
                        if netFrame then
                            local b = g_VR.viewModel:LookupBone("ValveBiped.Bip01_R_Hand")
                            if b then
                                local mtx = g_VR.viewModel:GetBoneMatrix(b)
                                netFrame.righthandPos = mtx:GetTranslation()
                                netFrame.righthandAng = mtx:GetAngles() - Angle(0, 0, 180)
                            end
                        end
                    end
                    
                    g_VR.viewModelMuzzle = g_VR.viewModel:GetAttachment(1)
                end
                
                -- ビューエンティティの更新
                local viewEnt = localply:GetViewEntity()
                
                if viewEnt ~= localply then
                    local rawPos, rawAng = WorldToLocal(
                        g_VR.tracking.hmd.pos, 
                        g_VR.tracking.hmd.ang, 
                        g_VR.origin, 
                        g_VR.originAngle
                    )
                    
                    if viewEnt ~= currentViewEnt then
                        local pos, ang = LocalToWorld(
                            rawPos, 
                            rawAng, 
                            viewEnt:GetPos(), 
                            viewEnt:GetAngles()
                        )
                        pos1, ang1 = WorldToLocal(
                            viewEnt:GetPos(), 
                            viewEnt:GetAngles(), 
                            pos, 
                            ang
                        )
                    end
                    
                    rawPos, rawAng = LocalToWorld(rawPos, rawAng, pos1, ang1)
                    g_VR.view.origin, g_VR.view.angles = LocalToWorld(
                        rawPos, 
                        rawAng, 
                        viewEnt:GetPos(), 
                        viewEnt:GetAngles()
                    )
                else
                    g_VR.view.origin, g_VR.view.angles = g_VR.tracking.hmd.pos, g_VR.tracking.hmd.ang
                end
                
                currentViewEnt = viewEnt
                
                -- 目の位置調整
                g_VR.view.origin = g_VR.view.origin + g_VR.view.angles:Forward() * -(eyez * g_VR.scale)
                g_VR.eyePosLeft = g_VR.view.origin + g_VR.view.angles:Right() * -(ipd * 0.5 * g_VR.scale)
                g_VR.eyePosRight = g_VR.view.origin + g_VR.view.angles:Right() * (ipd * 0.5 * g_VR.scale)
                
                -- 左目のレンダリング
                render.PushRenderTarget(g_VR.rt)
                g_VR.view.origin = g_VR.eyePosLeft
                g_VR.view.x = 0
                g_VR.view.fov = hfovLeft
                g_VR.view.aspectratio = aspectLeft
                
                hook.Call("VRMod_PreRender")
                render.RenderView(g_VR.view)
                
                -- 右目のレンダリング
                g_VR.view.origin = g_VR.eyePosRight
                g_VR.view.x = rtWidth / 2
                g_VR.view.fov = hfovRight
                g_VR.view.aspectratio = aspectRight
                
                hook.Call("VRMod_PreRenderRight")
                render.RenderView(g_VR.view)
                
                -- 死亡エフェクト
                if not LocalPlayer():Alive() then
                    cam.Start2D()
                    surface.SetDrawColor(255, 0, 0, 128)
                    surface.DrawRect(0, 0, rtWidth, rtHeight)
                    cam.End2D()
                end
                
                render.PopRenderTarget(g_VR.rt)
                
                -- デスクトップビュー表示
                if desktopView > 1 then
                    surface.SetDrawColor(255, 255, 255, 255)
                    surface.SetMaterial(mat_rt)
                    render.CullMode(1)
                    surface.DrawTexturedRectUV(
                        -1, -1, 2, 2, 
                        cropHorizontalOffset, 1 - cropVerticalMargin, 
                        0.5 + cropHorizontalOffset, cropVerticalMargin
                    )
                    render.CullMode(0)
                end
                
                hook.Call("VRMod_PostRender")
                return true
            end)
            
            -- ワールドモデル設定
            g_VR.usingWorldModels = convars.vrmod_useworldmodels:GetBool()
            
            if not g_VR.usingWorldModels then
                overrideConvar("viewmodel_fov", GetConVar("fov_desired"):GetString())
                
                hook.Add("CalcViewModelView", "vrutil_hook_calcviewmodelview", 
                    function(wep, vm, oldPos, oldAng, pos, ang) 
                        return g_VR.viewModelPos, g_VR.viewModelAng 
                    end
                )
                
                local blockViewModelDraw = true
                g_VR.allowPlayerDraw = false
                local hideplayer = convars.vrmod_floatinghands:GetBool()
                
                hook.Add("PostDrawTranslucentRenderables", "vrutil_hook_drawplayerandviewmodel",
                    function(bDrawingDepth, bDrawingSkybox)
                        if bDrawingSkybox or 
                        not LocalPlayer():Alive() or 
                        not (EyePos() == g_VR.eyePosLeft or EyePos() == g_VR.eyePosRight) then 
                            return 
                        end
                        
                        if IsValid(g_VR.viewModel) then
                            blockViewModelDraw = false
                            g_VR.viewModel:DrawModel()
                            blockViewModelDraw = true
                        end
                        
                        if not hideplayer then
                            g_VR.allowPlayerDraw = true
                            cam.Start3D() 
                            cam.End3D()
                            
                            local tmp = render.GetBlend()
                            render.SetBlend(1) 
                            LocalPlayer():DrawModel()
                            render.SetBlend(tmp)
                            
                            cam.Start3D()
                            cam.End3D()
                            
                            g_VR.allowPlayerDraw = false
                        end
                        
                        VRUtilRenderMenuSystem()
                    end
                )
                
                hook.Add("PreDrawPlayerHands", "vrutil_hook_predrawplayerhands", function() return true end)
                
                hook.Add("PreDrawViewModel", "vrutil_hook_predrawviewmodel", 
                    function(vm, ply, wep) 
                        return blockViewModelDraw or nil 
                    end
                )
            else
                g_VR.allowPlayerDraw = true
            end
            
            hook.Add("ShouldDrawLocalPlayer", "vrutil_hook_shoulddrawlocalplayer", 
                function(ply) 
                    return g_VR.allowPlayerDraw 
                end
            )
            
            -- レーザーポインター
            if convars.vrmod_laserpointer:GetBool() then
                local mat = Material("cable/redlaser")
                
                hook.Add("PostDrawTranslucentRenderables", "vr_laserpointer",
                    function(bDrawingDepth, bDrawingSkybox)
                        if bDrawingSkybox then return end
                        
                        if g_VR.viewModelMuzzle and not g_VR.menuFocus then
                            render.SetMaterial(mat)
                            render.DrawBeam(
                                g_VR.viewModelMuzzle.Pos, 
                                g_VR.viewModelMuzzle.Pos + g_VR.viewModelMuzzle.Ang:Forward() * 10000,
                                1, 0, 1, 
                                Color(255, 255, 255, 255)
                            )
                        end
                    end
                )
            end
        end

        -- VRクライアントの終了
        function VRUtilClientExit()
            if not g_VR.active then return end
            
            restoreConvarOverrides()
            VRUtilMenuClose()
            VRUtilNetworkCleanup()
            vrmod.StopLocomotion()
            
            if IsValid(g_VR.viewModel) and g_VR.viewModel:GetClass() == "class C_BaseFlex" then
                g_VR.viewModel:Remove()
            end
            
            g_VR.viewModel = nil
            g_VR.viewModelMuzzle = nil
            
            LocalPlayer():GetViewModel().RenderOverride = nil
            LocalPlayer():GetViewModel():RemoveEffects(EF_NODRAW)
            
            -- フックの削除
            hook.Remove("RenderScene", "vrutil_hook_renderscene")
            hook.Remove("PreDrawViewModel", "vrutil_hook_predrawviewmodel")
            hook.Remove("DrawPhysgunBeam", "vrutil_hook_drawphysgunbeam")
            hook.Remove("PreDrawHalos", "vrutil_hook_predrawhalos")
            hook.Remove("EntityFireBullets", "vrutil_hook_entityfirebullets")
            hook.Remove("Tick", "vrutil_hook_tick")
            hook.Remove("PostDrawSkyBox", "vrutil_hook_postdrawskybox")
            hook.Remove("CalcView", "vrutil_hook_calcview")
            hook.Remove("PostDrawTranslucentRenderables", "vr_laserpointer")
            hook.Remove("CalcViewModelView", "vrutil_hook_calcviewmodelview")
            hook.Remove("PostDrawTranslucentRenderables", "vrutil_hook_drawplayerandviewmodel")
            hook.Remove("PreDrawPlayerHands", "vrutil_hook_predrawplayerhands")
            hook.Remove("PreDrawViewModel", "vrutil_hook_predrawviewmodel")
            hook.Remove("ShouldDrawLocalPlayer", "vrutil_hook_shoulddrawlocalplayer")
            
            g_VR.tracking = {}
            g_VR.threePoints = false
            g_VR.sixPoints = false
            
            VRMOD_Shutdown()
            g_VR.active = false
        end

        -- シャットダウン時のクリーンアップ
        hook.Add("ShutDown", "vrutil_hook_shutdown", function()
            if IsValid(LocalPlayer()) and g_VR.net[LocalPlayer():SteamID()] then
                VRUtilClientExit()
            end
        end)
    elseif SERVER then
        -- サーバー側のバージョン通知
        CreateConVar("vrmod_version", vrmod.GetVersion(), FCVAR_NOTIFY)
    end

-- vrmod_api.lua
    -- VRモジュールの公開API関数を提供

    local addonVersion = 133
    local requiredModuleVersion = 20
    local latestModuleVersion = 21

    g_VR = g_VR or {}
    vrmod = vrmod or {}

    -- コンバーユーティリティ
    local convars, convarValues = {}, {}

    function vrmod.AddCallbackedConvar(cvarName, valueName, defaultValue, flags, helptext, min, max, conversionFunc, callbackFunc)
        valueName, flags, conversionFunc = (valueName or cvarName), (flags or FCVAR_ARCHIVE), (conversionFunc or function(val) return val end)
        
        local cv = CreateConVar(cvarName, defaultValue, flags, helptext, min, max)
        convars[cvarName], convarValues[valueName] = cv, conversionFunc(cv:GetString())
        
        cvars.AddChangeCallback(cvarName, function(cv_name, val_old, val_new)
            convarValues[valueName] = conversionFunc(val_new)
            if callbackFunc then
                callbackFunc(convarValues[valueName])
            end
        end, "vrmod")
        
        return convars, convarValues
    end

    function vrmod.GetConvars()
        return convars, convarValues
    end

    function vrmod.GetVersion()
        return addonVersion
    end

    if CLIENT then
        g_VR.net = g_VR.net or {}
        g_VR.viewModelInfo = g_VR.viewModelInfo or {}
        g_VR.locomotionOptions = g_VR.locomotionOptions or {}
        g_VR.menuItems = g_VR.menuItems or {}
        
        function vrmod.GetStartupError()
            local error = nil
            
            if g_VR.moduleVersion == 0 then
                if not file.Exists("lua/bin/gmcl_vrmod_win32.dll", "GAME") then
                    error = "Module not installed. Read the workshop description for instructions.\n"
                else
                    error = "Failed to load module\n"
                end
            elseif g_VR.moduleVersion < requiredModuleVersion then
                error = "Module update required.\nRun the module installer to update.\nIf you don't have the installer anymore you can re-download it from the workshop description.\n\nInstalled: v" .. g_VR.moduleVersion .. "\nRequired: v" .. requiredModuleVersion
            elseif g_VR.active then
                error = "Already running"
            elseif g_VR.moduleVersion > latestModuleVersion then
                error = "Unknown module version\n\nInstalled: v" .. g_VR.moduleVersion .. "\nRequired: v" .. requiredModuleVersion .. "\n\nMake sure the addon is up to date.\nAddon version: " .. addonVersion
            elseif VRMOD_IsHMDPresent and not VRMOD_IsHMDPresent() then
                error = "VR headset not detected\n"
            end
            
            return error
        end
        
        function vrmod.GetModuleVersion()
            return g_VR.moduleVersion, requiredModuleVersion, latestModuleVersion
        end
        
        -- プレイヤーVR状態チェック
        function vrmod.IsPlayerInVR(ply)
            return g_VR.net[ply and ply:SteamID() or LocalPlayer():SteamID()] ~= nil
        end
        
        -- 空の手チェック
        function vrmod.UsingEmptyHands(ply)
            local wep = ply and ply:GetActiveWeapon() or LocalPlayer():GetActiveWeapon()
            return IsValid(wep) and wep:GetClass() == "weapon_vrmod_empty" or false
        end
        
        -- HMD位置取得
        function vrmod.GetHMDPos(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.hmdPos or Vector()
        end
        
        -- HMD角度取得
        function vrmod.GetHMDAng(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.hmdAng or Angle()
        end
        
        -- HMDポーズ取得
        function vrmod.GetHMDPose(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            if t and t.lerpedFrame then
                return t.lerpedFrame.hmdPos, t.lerpedFrame.hmdAng
            end
            return Vector(), Angle()
        end
        
        -- HMD速度取得
        function vrmod.GetHMDVelocity()
            return g_VR.threePoints and g_VR.tracking.hmd.vel or Vector()
        end
        
        -- HMD角速度取得
        function vrmod.GetHMDAngularVelocity()
            return g_VR.threePoints and g_VR.tracking.hmd.angvel or Vector()
        end
        
        -- HMD速度・角速度取得
        function vrmod.GetHMDVelocities()
            if g_VR.threePoints then
                return g_VR.tracking.hmd.vel, g_VR.tracking.hmd.angvel
            end
            return Vector(), Vector()
        end
        
        -- 左手位置取得
        function vrmod.GetLeftHandPos(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.lefthandPos or Vector()
        end
        
        -- 左手角度取得
        function vrmod.GetLeftHandAng(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.lefthandAng or Angle()
        end
        
        -- 左手ポーズ取得
        function vrmod.GetLeftHandPose(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            if t and t.lerpedFrame then
                return t.lerpedFrame.lefthandPos, t.lerpedFrame.lefthandAng
            end
            return Vector(), Angle()
        end
        
        -- 左手速度取得
        function vrmod.GetLeftHandVelocity()
            return g_VR.threePoints and g_VR.tracking.pose_lefthand.vel or Vector()
        end
        
        -- 左手角速度取得
        function vrmod.GetLeftHandAngularVelocity()
            return g_VR.threePoints and g_VR.tracking.pose_lefthand.angvel or Vector()
        end
        
        -- 左手速度・角速度取得
        function vrmod.GetLeftHandVelocities()
            if g_VR.threePoints then
                return g_VR.tracking.pose_lefthand.vel, g_VR.tracking.pose_lefthand.angvel
            end
            return Vector(), Vector()
        end
        
        -- 右手位置取得
        function vrmod.GetRightHandPos(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.righthandPos or Vector()
        end
        
        -- 右手角度取得
        function vrmod.GetRightHandAng(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            return t and t.lerpedFrame and t.lerpedFrame.righthandAng or Angle()
        end
        
        -- 右手ポーズ取得
        function vrmod.GetRightHandPose(ply)
            local t = ply and g_VR.net[ply:SteamID()] or g_VR.net[LocalPlayer():SteamID()]
            if t and t.lerpedFrame then
                return t.lerpedFrame.righthandPos, t.lerpedFrame.righthandAng
            end
            return Vector(), Angle()
        end
        
        -- 右手速度取得
        function vrmod.GetRightHandVelocity()
            return g_VR.threePoints and g_VR.tracking.pose_righthand.vel or Vector()
        end
        
        -- 右手角速度取得
        function vrmod.GetRightHandAngularVelocity()
            return g_VR.threePoints and g_VR.tracking.pose_righthand.angvel or Vector()
        end
        
        -- 右手速度・角速度取得
        function vrmod.GetRightHandVelocities()
            if g_VR.threePoints then
                return g_VR.tracking.pose_righthand.vel, g_VR.tracking.pose_righthand.angvel
            end
            return Vector(), Vector()
        end
        
        -- 左手ポーズ設定
        function vrmod.SetLeftHandPose(pos, ang)
            local t = g_VR.net[LocalPlayer():SteamID()]
            if t and t.lerpedFrame then
                t.lerpedFrame.lefthandPos, t.lerpedFrame.lefthandAng = pos, ang
            end
        end
        
        -- 右手ポーズ設定
        function vrmod.SetRightHandPose(pos, ang)
            local t = g_VR.net[LocalPlayer():SteamID()]
            if t and t.lerpedFrame then
                t.lerpedFrame.righthandPos, t.lerpedFrame.righthandAng = pos, ang
            end
        end
        
        -- 指の角度取得/設定
        function vrmod.GetLeftHandOpenFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.openHandAngles[i]
            end
            return r
        end
        
        function vrmod.GetLeftHandClosedFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.closedHandAngles[i]
            end
            return r
        end
        
        function vrmod.GetRightHandOpenFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.openHandAngles[15+i]
            end
            return r
        end
        
        function vrmod.GetRightHandClosedFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.closedHandAngles[15+i]
            end
            return r
        end
        
        function vrmod.SetLeftHandOpenFingerAngles(tbl)
            local t = table.Copy(g_VR.openHandAngles)
            for i = 1, 15 do
                t[i] = tbl[i]
            end
            g_VR.openHandAngles = t
        end
        
        function vrmod.SetLeftHandClosedFingerAngles(tbl)
            local t = table.Copy(g_VR.closedHandAngles)
            for i = 1, 15 do
                t[i] = tbl[i]
            end
            g_VR.closedHandAngles = t
        end
        
        function vrmod.SetRightHandOpenFingerAngles(tbl)
            local t = table.Copy(g_VR.openHandAngles)
            for i = 1, 15 do
                t[15+i] = tbl[i]
            end
            g_VR.openHandAngles = t
        end
        
        function vrmod.SetRightHandClosedFingerAngles(tbl)
            local t = table.Copy(g_VR.closedHandAngles)
            for i = 1, 15 do
                t[15+i] = tbl[i]
            end
            g_VR.closedHandAngles = t
        end
        
        function vrmod.GetDefaultLeftHandOpenFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.defaultOpenHandAngles[i]
            end
            return r
        end
        
        function vrmod.GetDefaultLeftHandClosedFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.defaultClosedHandAngles[i]
            end
            return r
        end
        
        function vrmod.GetDefaultRightHandOpenFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.defaultOpenHandAngles[15+i]
            end
            return r
        end
        
        function vrmod.GetDefaultRightHandClosedFingerAngles()
            local r = {}
            for i = 1, 15 do
                r[i] = g_VR.defaultClosedHandAngles[15+i]
            end
            return r
        end
        
        -- モデルから指の角度取得
        local fingerAngleCache = {}
        local fingerAngleCachePM = ""
        
        local function GetFingerAnglesFromModel(modelName, sequenceNumber)
            sequenceNumber = sequenceNumber or 0
            local pm = convars.vrmod_floatinghands:GetBool() and "models/weapons/c_arms.mdl" or LocalPlayer():GetModel()
            
            if fingerAngleCachePM ~= pm then
                fingerAngleCachePM = pm
                fingerAngleCache = {}
            end
            
            local cache = fingerAngleCache[modelName .. sequenceNumber]
            if cache then return cache end
            
            local pmdl = ClientsideModel(pm)
            pmdl:SetupBones()
            
            local tmdl = ClientsideModel(modelName)
            tmdl:ResetSequence(sequenceNumber)
            tmdl:SetupBones()
            
            local tmp = {"0", "01", "02", "1", "11", "12", "2", "21", "22", "3", "31", "32", "4", "41", "42"}
            local r = {}
            
            for i = 1, 30 do
                r[i] = Angle()
                local fingerBoneName = "ValveBiped.Bip01_" .. ((i < 16) and "L" or "R") .. "_Finger" .. tmp[i - (i < 16 and 0 or 15)]
                local pfinger = pmdl:LookupBone(fingerBoneName) or -1
                local tfinger = tmdl:LookupBone(fingerBoneName) or -1
                
                if pmdl:GetBoneMatrix(pfinger) then
                    local _, pmoffset = WorldToLocal(
                        Vector(0, 0, 0),
                        pmdl:GetBoneMatrix(pfinger):GetAngles(),
                        Vector(0, 0, 0),
                        pmdl:GetBoneMatrix(pmdl:GetBoneParent(pfinger)):GetAngles()
                    )
                    
                    if tfinger ~= -1 then
                        local _, tmoffset = WorldToLocal(
                            Vector(0, 0, 0),
                            tmdl:GetBoneMatrix(tfinger):GetAngles(),
                            Vector(0, 0, 0),
                            tmdl:GetBoneMatrix(tmdl:GetBoneParent(tfinger)):GetAngles()
                        )
                        r[i] = tmoffset - pmoffset
                    end
                end
            end
            
            pmdl:Remove()
            tmdl:Remove()
            fingerAngleCache[modelName .. sequenceNumber] = r
            return r
        end
        
        function vrmod.GetLeftHandFingerAnglesFromModel(modelName, sequenceNumber)
            local angles = GetFingerAnglesFromModel(modelName, sequenceNumber)
            local r = {}
            for i = 1, 15 do
                r[i] = angles[i]
            end
            return r
        end
        
        function vrmod.GetRightHandFingerAnglesFromModel(modelName, sequenceNumber)
            local angles = GetFingerAnglesFromModel(modelName, sequenceNumber)
            local r = {}
            for i = 1, 15 do
                r[i] = angles[15+i]
            end
            return r
        end
        
        -- モデルからポーズ取得
        local function GetRelativeBonePoseFromModel(modelName, sequenceNumber, boneName, refBoneName)
            local ent = ClientsideModel(modelName)
            ent:ResetSequence(sequenceNumber or 0)
            ent:SetupBones()
            
            local mtx = ent:GetBoneMatrix(ent:LookupBone(boneName))
            local mtxRef = ent:GetBoneMatrix(refBoneName and ent:LookupBone(refBoneName) or 0)
            
            local relativePos, relativeAng = WorldToLocal(
                mtx:GetTranslation(), 
                mtx:GetAngles(), 
                mtxRef:GetTranslation(), 
                mtxRef:GetAngles()
            )
            
            ent:Remove()
            return relativePos, relativeAng
        end
        
        function vrmod.GetLeftHandPoseFromModel(modelName, sequenceNumber, refBoneName)
            return GetRelativeBonePoseFromModel(
                modelName, 
                sequenceNumber, 
                "ValveBiped.Bip01_L_Hand", 
                refBoneName
            )
        end
        
        function vrmod.GetRightHandPoseFromModel(modelName, sequenceNumber, refBoneName)
            return GetRelativeBonePoseFromModel(
                modelName, 
                sequenceNumber, 
                "ValveBiped.Bip01_R_Hand", 
                refBoneName
            )
        end
        
        -- 補間関数
        function vrmod.GetLerpedFingerAngles(fraction, from, to)
            local r = {}
            for i = 1, 15 do
                r[i] = LerpAngle(fraction, from[i], to[i])
            end
            return r
        end
        
        function vrmod.GetLerpedHandPose(fraction, fromPos, fromAng, toPos, toAng)
            return LerpVector(fraction, fromPos, toPos), LerpAngle(fraction, fromAng, toAng)
        end
        
        -- 入力取得
        function vrmod.GetInput(name)
            return g_VR.input[name]
        end
        
        -- メニュー関連関数のプレースホルダー
        vrmod.MenuCreate = function() end
        vrmod.MenuClose = function() end
        vrmod.MenuExists = function() end
        vrmod.MenuRenderStart = function() end
        vrmod.MenuRenderEnd = function() end
        vrmod.MenuCursorPos = function() 
            return g_VR.menuCursorX, g_VR.menuCursorY
        end
        vrmod.MenuFocused = function()
            return g_VR.menuFocus
        end
        
        -- メニュー関数の実装を遅延設定
        timer.Simple(0, function()
            vrmod.MenuCreate = VRUtilMenuOpen
            vrmod.MenuClose = VRUtilMenuClose
            vrmod.MenuExists = VRUtilIsMenuOpen
            vrmod.MenuRenderStart = VRUtilMenuRenderStart
            vrmod.MenuRenderEnd = VRUtilMenuRenderEnd
        end)
        
        -- ビューモデルオフセット設定
        function vrmod.SetViewModelOffsetForWeaponClass(classname, pos, ang)
            g_VR.viewModelInfo[classname] = g_VR.viewModelInfo[classname] or {}
            g_VR.viewModelInfo[classname].offsetPos = pos
            g_VR.viewModelInfo[classname].offsetAng = ang
        end
        
        -- 移動システム設定
        vrmod.AddCallbackedConvar("vrmod_locomotion", nil, "1")
        
        function vrmod.AddLocomotionOption(name, startfunc, stopfunc, buildcpanelfunc)
            g_VR.locomotionOptions[#g_VR.locomotionOptions + 1] = {
                name = name,
                startfunc = startfunc,
                stopfunc = stopfunc,
                buildcpanelfunc = buildcpanelfunc
            }
        end
        
        function vrmod.StartLocomotion()
            local selectedOption = g_VR.locomotionOptions[convars.vrmod_locomotion:GetInt()]
            if selectedOption then
                selectedOption.startfunc()
            end
        end
        
        function vrmod.StopLocomotion()
            local selectedOption = g_VR.locomotionOptions[convars.vrmod_locomotion:GetInt()]
            if selectedOption then
                selectedOption.stopfunc()
            end
        end
        
        -- 移動システムUIの設定
        hook.Add("VRMod_Menu", "locomotion_selection", function(frame)
            local locomotionPanel = vgui.Create("DPanel")
            frame.SettingsForm:AddItem(locomotionPanel)
            
            local dlabel = vgui.Create("DLabel", locomotionPanel)
            dlabel:SetSize(100, 30)
            dlabel:SetPos(5, -3)
            dlabel:SetText("Locomotion:")
            dlabel:SetColor(Color(0, 0, 0))
            
            local locomotionControls = nil
            
            local function updateLocomotionCPanel(index)
                if IsValid(locomotionControls) then
                    locomotionControls:Remove()
                end
                
                locomotionControls = vgui.Create("DPanel")
                locomotionControls.Paint = function() end
                
                g_VR.locomotionOptions[index].buildcpanelfunc(locomotionControls)
                
                locomotionControls:InvalidateLayout(true)
                locomotionControls:SizeToChildren(true, true)
                locomotionPanel:Add(locomotionControls)
                locomotionControls:Dock(TOP)
                locomotionPanel:InvalidateLayout(true)
                locomotionPanel:SizeToChildren(true, true)
            end
            
            local DComboBox = vgui.Create("DComboBox")
            locomotionPanel:Add(DComboBox)
            DComboBox:Dock(TOP)
            DComboBox:DockMargin(70, 0, 0, 5)
            DComboBox:SetValue("none")
            
            for i = 1, #g_VR.locomotionOptions do
                DComboBox:AddChoice(g_VR.locomotionOptions[i].name)
            end
            
            DComboBox.OnSelect = function(self, index, value)
                convars.vrmod_locomotion:SetInt(index)
            end
            
            DComboBox.Think = function(self)
                local v = convars.vrmod_locomotion:GetInt()
                if self.ConvarVal ~= v then
                    self.ConvarVal = v
                    if g_VR.locomotionOptions[v] then
                        self:ChooseOptionID(v)
                        updateLocomotionCPanel(v)
                    end
                end
            end
        end)
        
        -- 原点関連
        function vrmod.GetOrigin()
            return g_VR.origin, g_VR.originAngle
        end
        
        function vrmod.GetOriginPos()
            return g_VR.origin
        end
        
        function vrmod.GetOriginAng()
            return g_VR.originAngle
        end
        
        function vrmod.SetOrigin(pos, ang)
            g_VR.origin = pos
            g_VR.originAngle = ang
        end
        
        function vrmod.SetOriginPos(pos)
            g_VR.origin = pos
        end
        
        function vrmod.SetOriginAng(ang)
            g_VR.originAngle = ang
        end
        
        -- メニューアイテム
        function vrmod.AddInGameMenuItem(name, slot, slotpos, func)
            local index = #g_VR.menuItems + 1
            for i = 1, #g_VR.menuItems do
                if g_VR.menuItems[i].name == name then
                    index = i
                end
            end
            g_VR.menuItems[index] = {
                name = name,
                slot = slot,
                slotPos = slotpos,
                func = func
            }
        end
        
        function vrmod.RemoveInGameMenuItem(name)
            for i = 1, #g_VR.menuItems do
                if g_VR.menuItems[i].name == name then
                    table.remove(g_VR.menuItems, i)
                    return
                end
            end
        end
        
        -- 目の位置取得
        function vrmod.GetLeftEyePos()
            return g_VR.eyePosLeft or Vector()
        end
        
        function vrmod.GetRightEyePos()
            return g_VR.eyePosRight or Vector()
        end
        
        function vrmod.GetEyePos()
            return g_VR.view and g_VR.view.origin or Vector()
        end
        
        -- トラッキングデバイス名取得
        function vrmod.GetTrackedDeviceNames()
            return g_VR.active and VRMOD_GetTrackedDeviceNames and VRMOD_GetTrackedDeviceNames() or {}
        end
    elseif SERVER then
        -- サーバー側のネットワーク制限付き受信
        function vrmod.NetReceiveLimited(msgName, maxCountPerSec, maxLen, callback)
            local msgCounts = {}
            
            net.Receive(msgName, function(len, ply)
                local t = msgCounts[ply] or {count = 0, time = 0}
                msgCounts[ply], t.count = t, t.count + 1
                
                if SysTime() - t.time >= 1 then
                    t.count, t.time = 1, SysTime()
                end
                
                if t.count > maxCountPerSec or len > maxLen then
                    return
                end
                
                callback(len, ply)
            end)
        end
        
        -- サーバー側API
        function vrmod.IsPlayerInVR(ply)
            return g_VR[ply:SteamID()] ~= nil
        end
        
        function vrmod.UsingEmptyHands(ply)
            local wep = ply:GetActiveWeapon()
            return IsValid(wep) and wep:GetClass() == "weapon_vrmod_empty" or false
        end
        
        -- ワールドポーズ更新
        local function UpdateWorldPoses(ply, playerTable)
            if not playerTable.latestFrameWorld or playerTable.latestFrameWorld.tick ~= engine.TickCount() then
                playerTable.latestFrameWorld = playerTable.latestFrameWorld or {}
                local lf = playerTable.latestFrame
                local lfw = playerTable.latestFrameWorld
                
                lfw.tick = engine.TickCount()
                
                local refPos = ply:GetPos()
                local refAng = ply:InVehicle() and ply:GetVehicle():GetAngles() or Angle()
                
                lfw.hmdPos, lfw.hmdAng = LocalToWorld(lf.hmdPos, lf.hmdAng, refPos, refAng)
                lfw.lefthandPos, lfw.lefthandAng = LocalToWorld(lf.lefthandPos, lf.lefthandAng, refPos, refAng)
                lfw.righthandPos, lfw.righthandAng = LocalToWorld(lf.righthandPos, lf.righthandAng, refPos, refAng)
            end
        end
        
        -- HMD位置取得（サーバー側）
        function vrmod.GetHMDPos(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Vector() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.hmdPos
        end
        
        -- HMD角度取得（サーバー側）
        function vrmod.GetHMDAng(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Angle() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.hmdAng
        end
        
        -- HMDポーズ取得（サーバー側）
        function vrmod.GetHMDPose(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then
                return Vector(), Angle()
            end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.hmdPos, playerTable.latestFrameWorld.hmdAng
        end
        
        -- 左手位置取得（サーバー側）
        function vrmod.GetLeftHandPos(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Vector() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.lefthandPos
        end
        
        -- 左手角度取得（サーバー側）
        function vrmod.GetLeftHandAng(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Angle() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.lefthandAng
        end
        
        -- 左手ポーズ取得（サーバー側）
        function vrmod.GetLeftHandPose(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then
                return Vector(), Angle()
            end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.lefthandPos, playerTable.latestFrameWorld.lefthandAng
        end
        
        -- 右手位置取得（サーバー側）
        function vrmod.GetRightHandPos(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Vector() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.righthandPos
        end
        
        -- 右手角度取得（サーバー側）
        function vrmod.GetRightHandAng(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then return Angle() end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.righthandAng
        end
        
        -- 右手ポーズ取得（サーバー側）
        function vrmod.GetRightHandPose(ply)
            local playerTable = g_VR[ply:SteamID()]
            if not (playerTable and playerTable.latestFrame) then
                return Vector(), Angle()
            end
            
            UpdateWorldPoses(ply, playerTable)
            return playerTable.latestFrameWorld.righthandPos, playerTable.latestFrameWorld.righthandAng
        end
    end

    -- フック名変換テーブル
    local hookTranslations = {
        VRUtilEventTracking         = "VRMod_Tracking",
        VRUtilEventInput            = "VRMod_Input",
        VRUtilEventPreRender        = "VRMod_PreRender",
        VRUtilEventPreRenderRight   = "VRMod_PreRenderRight",
        VRUtilEventPostRender       = "VRMod_PostRender",
        VRUtilStart                 = "VRMod_Start",
        VRUtilExit                  = "VRMod_Exit",
        VRUtilEventPickup           = "VRMod_Pickup",
        VRUtilEventDrop             = "VRMod_Drop",
        VRUtilAllowDefaultAction    = "VRMod_AllowDefaultAction"
    }

    -- 既存フックの変換
    local hooks = hook.GetTable()
    for k, v in pairs(hooks) do
        local translation = hookTranslations[k]
        if translation then
            hooks[translation] = hooks[translation] or {}
            for k2, v2 in pairs(v) do
                hooks[translation][k2] = v2
            end
            hooks[k] = nil
        end
    end

    -- フック関数のオーバーライド
    local orig_hook_add = hook.Add
    hook.Add = function(...)
        local args = {...}
        args[1] = hookTranslations[args[1]] or args[1]
        orig_hook_add(unpack(args))
    end

    local orig_hook_remove = hook.Remove
    hook.Remove = function(...)
        local args = {...}
        args[1] = hookTranslations[args[1]] or args[1]
        orig_hook_remove(unpack(args))
    end

-- vrmod_input.lua
    -- VRモジュールの入力処理を提供

    if CLIENT then
        -- 車両乗車時のアクションセット切り替え
        hook.Add("VRMod_EnterVehicle", "vrmod_switchactionset", function()
            VRMOD_SetActiveActionSets("/actions/base", "/actions/driving")
        end)
        
        hook.Add("VRMod_ExitVehicle", "vrmod_switchactionset", function()
            VRMOD_SetActiveActionSets("/actions/base", "/actions/main")
        end)
        
        -- デフォルト入力処理
        hook.Add("VRMod_Input", "vrutil_hook_defaultinput", function(action, pressed)
            if hook.Call("VRMod_AllowDefaultAction", nil, action) == false then return end
            
            -- プライマリ発射
            if (action == "boolean_primaryfire" or action == "boolean_turret") and not g_VR.menuFocus then
                LocalPlayer():ConCommand(pressed and "+attack" or "-attack")
                return
            end
            
            -- セカンダリ発射
            if action == "boolean_secondaryfire" then
                LocalPlayer():ConCommand(pressed and "+attack2" or "-attack2")
                return
            end
            
            -- アイテム掴み
            if action == "boolean_left_pickup" then
                vrmod.Pickup(true, not pressed)
                return
            end
            
            if action == "boolean_right_pickup" then
                vrmod.Pickup(false, not pressed)
                return
            end
            
            -- Use/相互作用
            if action == "boolean_use" or action == "boolean_exit" then
                if pressed then
                    LocalPlayer():ConCommand("+use")
                    local wep = LocalPlayer():GetActiveWeapon()
                    
                    if IsValid(wep) and wep:GetClass() == "weapon_physgun" then
                        hook.Add("CreateMove", "vrutil_hook_cmphysguncontrol", function(cmd)
                            if g_VR.input.vector2_walkdirection.y > 0.9 then
                                cmd:SetButtons(bit.bor(cmd:GetButtons(), IN_FORWARD))
                            elseif g_VR.input.vector2_walkdirection.y < -0.9 then
                                cmd:SetButtons(bit.bor(cmd:GetButtons(), IN_BACK))
                            else
                                cmd:SetMouseX(g_VR.input.vector2_walkdirection.x * 50)
                                cmd:SetMouseY(g_VR.input.vector2_walkdirection.y * -50)
                            end
                        end)
                    end
                else
                    LocalPlayer():ConCommand("-use")
                    hook.Remove("CreateMove", "vrutil_hook_cmphysguncontrol")
                end
                return
            end
            
            -- 武器変更
            if action == "boolean_changeweapon" then
                if pressed then
                    VRUtilWeaponMenuOpen()
                else
                    VRUtilWeaponMenuClose()
                end
                return
            end
            
            -- フラッシュライト
            if action == "boolean_flashlight" and pressed then
                LocalPlayer():ConCommand("impulse 100")
                return
            end
            
            -- リロード
            if action == "boolean_reload" then
                LocalPlayer():ConCommand(pressed and "+reload" or "-reload")
                return
            end
            
            -- アンドゥ
            if action == "boolean_undo" then
                if pressed then
                    LocalPlayer():ConCommand("gmod_undo")
                end
                return
            end
            
            -- スポーンメニュー
            if action == "boolean_spawnmenu" then
                if pressed then
                    g_VR.MenuOpen()
                else
                    g_VR.MenuClose()
                end
                return
            end
            
            -- カスタムアクション
            for i = 1, #g_VR.CustomActions do
                if action == g_VR.CustomActions[i][1] then
                    local commands = string.Explode(";", g_VR.CustomActions[i][pressed and 2 or 3], false)
                    for j = 1, #commands do
                        local args = string.Explode(" ", commands[j], false)
                        RunConsoleCommand(args[1], unpack(args, 2))
                    end
                end
            end
        end)
    end

-- vrmod_locomotion.lua
    -- VRでの移動（ロコモーション）システム

    local cv_allowtp = CreateConVar("vrmod_allow_teleport", "1", FCVAR_REPLICATED)

    if SERVER then 
        -- テレポート処理
        util.AddNetworkString("vrmod_teleport")
        
        vrmod.NetReceiveLimited("vrmod_teleport", 10, 200, function(len, ply)
            if cv_allowtp:GetBool() and 
            g_VR[ply:SteamID()] ~= nil and 
            (hook.Run("PlayerNoClip", ply, true) == true or 
                ULib and ULib.ucl.query(ply, "ulx noclip") == true) then
                
                ply:SetPos(net.ReadVector())
            end
        end)
        
        return
    end

    -- テレポートビーム
    local tpBeamMatrices, tpBeamEnt, tpBeamHitPos = {}, nil, nil
    for i = 1, 17 do 
        tpBeamMatrices[i] = Matrix() 
    end

    -- テレポート入力処理
    hook.Add("VRMod_Input", "teleport", function(action, pressed)
        if action == "boolean_chat" and not LocalPlayer():InVehicle() then
            if pressed then
                -- テレポートビーム作成
                tpBeamEnt = ClientsideModel("models/vrmod/tpbeam.mdl")
                tpBeamEnt:SetRenderMode(RENDERMODE_TRANSCOLOR)
                
                tpBeamEnt.RenderOverride = function(self)
                    render.SuppressEngineLighting(true)
                    self:SetupBones()
                    
                    for i = 1, 17 do
                        self:SetBoneMatrix(i - 1, tpBeamMatrices[i])
                    end
                    
                    self:DrawModel()
                    render.SetColorModulation(1, 1, 1)
                    render.SuppressEngineLighting(false)
                end
                
                -- テレポートビーム更新
                hook.Add("VRMod_PreRender", "teleport", function()
                    local controllerPos = g_VR.tracking.pose_lefthand.pos
                    local controllerDir = g_VR.tracking.pose_lefthand.ang:Forward()
                    prevPos = controllerPos
                    local hit = false
                    
                    for i = 2, 17 do
                        local d = i - 1
                        local nextPos = controllerPos + controllerDir * 50 * d + Vector(0, 0, -d * d * 3)
                        local v = nextPos - prevPos
                        
                        if not hit then
                            local tr = util.TraceLine({
                                start = prevPos, 
                                endpos = prevPos + v, 
                                filter = LocalPlayer(), 
                                mask = MASK_PLAYERSOLID
                            })
                            
                            hit = tr.Hit
                            
                            if hit then
                                tpBeamMatrices[1] = Matrix()
                                tpBeamMatrices[1]:Translate(tr.HitPos + tr.HitNormal)
                                tpBeamMatrices[1]:Rotate(tr.HitNormal:Angle() + Angle(90, 0, 90))
                                
                                if tr.HitNormal.z < 0.7 then
                                    tpBeamMatrices[1]:Scale(Vector(0.5, 0.5, 0.5))
                                    tpBeamEnt:SetColor(Color(255, 100, 100, 150))
                                    tpBeamHitPos = nil
                                else
                                    tpBeamEnt:SetColor(Color(100, 255, 100, 150))
                                    tpBeamHitPos = tr.HitPos
                                end
                                
                                tpBeamEnt:SetPos(tr.HitPos)
                            end
                        end
                        
                        tpBeamMatrices[i] = Matrix()
                        tpBeamMatrices[i]:Translate(prevPos + v * 0.5)
                        tpBeamMatrices[i]:Rotate(v:Angle() + Angle(-90, 0, 0))
                        tpBeamMatrices[i]:Scale(Vector(0.5, 0.5, v:Length()))
                        
                        prevPos = nextPos
                    end
                    
                    if not hit then
                        tpBeamEnt:SetColor(Color(0, 0, 0, 0))
                        tpBeamHitPos = nil
                    end
                end)
            else
                -- テレポート実行
                tpBeamEnt:Remove()
                hook.Remove("VRMod_PreRender", "teleport")
                
                if tpBeamHitPos then
                    net.Start("vrmod_teleport")
                    net.WriteVector(tpBeamHitPos) 
                    net.SendToServer()
                end
            end
        end
    end)

    if SERVER then return end

    -- ロコモーション設定
    local convars, convarValues = vrmod.AddCallbackedConvar("vrmod_controlleroriented", "controllerOriented", "0", nil, nil, nil, nil, tobool)
    vrmod.AddCallbackedConvar("vrmod_smoothturn", "smoothTurn", "0", nil, nil, nil, nil, tobool)
    vrmod.AddCallbackedConvar("vrmod_smoothturnrate", "smoothTurnRate", "180", nil, nil, nil, nil, tonumber)
    vrmod.AddCallbackedConvar("vrmod_crouchthreshold", "crouchThreshold", "40", nil, nil, nil, nil, tonumber)

    -- ユーティリティ変数
    local zeroVec, zeroAng = Vector(), Angle()
    local upVec = Vector(0, 0, 1)

    -- ロコモーション開始
    local function start()
        local ply = LocalPlayer()
        local followVec = zeroVec
        local originVehicleLocalPos, originVehicleLocalAng = zeroVec, zeroAng
        
        -- 車両ビューリセットメニュー項目
        vrmod.AddInGameMenuItem("Reset Vehicle View", 3, 1, function()
            originVehicleLocalPos = nil
        end)
        
        -- ロコモーション更新
        hook.Add("PreRender", "vrmod_locomotion", function()
            if not g_VR.threePoints then return end
            
            -- 車両処理
            if ply:InVehicle() then
                local v = ply:GetVehicle()
                local attachment = v:GetAttachment(v:LookupAttachment("vehicle_driver_eyes"))
                
                if not originVehicleLocalPos then
                    local originHmdRelV, originHmdRelA = WorldToLocal(
                        g_VR.origin, 
                        g_VR.originAngle, 
                        g_VR.tracking.hmd.pos, 
                        Angle(0, g_VR.tracking.hmd.ang.yaw, 0)
                    ) 
                    
                    g_VR.origin, g_VR.originAngle = LocalToWorld(
                        originHmdRelV + Vector(7, 0, 2), 
                        originHmdRelA, 
                        attachment.Pos, 
                        attachment.Ang
                    ) 
                    
                    originVehicleLocalPos, originVehicleLocalAng = WorldToLocal(
                        g_VR.origin, 
                        g_VR.originAngle, 
                        attachment.Pos, 
                        attachment.Ang
                    ) 
                end
                
                g_VR.origin, g_VR.originAngle = LocalToWorld(
                    originVehicleLocalPos, 
                    originVehicleLocalAng, 
                    attachment.Pos, 
                    attachment.Ang
                )
                
                return
            end
            
            -- 車両から降りた時の処理
            if originVehicleLocalPos then
                originVehicleLocalPos = nil
                g_VR.originAngle = Angle(0, g_VR.originAngle.yaw, 0)
            end
            
            local plyPos = ply:GetPos()
            
            -- 回転処理
            local turnAmount = convarValues.smoothTurn and 
                            -g_VR.input.vector2_smoothturn.x * convarValues.smoothTurnRate * RealFrameTime() or 
                            g_VR.changedInputs.boolean_turnright and -30 or 
                            g_VR.changedInputs.boolean_turnleft and 30 or 0
            
            if turnAmount ~= 0 then
                g_VR.origin = LocalToWorld(
                    g_VR.origin - plyPos, 
                    zeroAng, 
                    plyPos, 
                    Angle(0, turnAmount, 0)
                )
                g_VR.originAngle.yaw = g_VR.originAngle.yaw + turnAmount
            end
            
            -- 追従ベクトル計算
            local plyTargetPos = g_VR.tracking.hmd.pos + upVec:Cross(g_VR.tracking.hmd.ang:Right()) * -10
            followVec = (ply:GetMoveType() == MOVETYPE_NOCLIP) and 
                        zeroVec or 
                        Vector((plyTargetPos.x - plyPos.x) * 8, (plyPos.y - plyTargetPos.y) * -8, 0)
            
            -- 過剰な追従防止
            if followVec:LengthSqr() > 262144 then 
                local prevOrigin = g_VR.origin
                g_VR.origin = g_VR.origin + (plyPos - plyTargetPos)
                g_VR.origin.z = plyPos.z
                followVec = zeroVec
                return
            end
            
            -- 原点速度更新
            local groundEnt = ply:GetGroundEntity()
            local groundVel = IsValid(groundEnt) and groundEnt:GetVelocity() or zeroVec
            originVelocity = ply:GetVelocity() - followVec + groundVel
            originVelocity.z = 0
            
            if originVelocity:Length() < 15 then
                originVelocity = zeroVec
            end
            
            -- 原点位置更新
            g_VR.origin = g_VR.origin + originVelocity * FrameTime()
            g_VR.origin.z = plyPos.z
        end)
        
        -- 移動コマンド処理
        hook.Add("CreateMove", "vrmod_locomotion", function(cmd)
            if not g_VR.threePoints then return end
            
            -- 車両操作
            if ply:InVehicle() then
                cmd:SetForwardMove((g_VR.input.vector1_forward - g_VR.input.vector1_reverse) * 400)
                cmd:SetSideMove(g_VR.input.vector2_steer.x * 400)
                
                local _, relativeAng = WorldToLocal(
                    Vector(0, 0, 0),
                    g_VR.tracking.hmd.ang,
                    Vector(0, 0, 0),
                    ply:GetVehicle():GetAngles()
                )
                
                cmd:SetViewAngles(relativeAng) 
                
                cmd:SetButtons(bit.bor(
                    cmd:GetButtons(),
                    g_VR.input.boolean_turbo and IN_SPEED or 0,
                    g_VR.input.boolean_handbrake and IN_JUMP or 0
                ))
                
                return
            end
            
            -- 通常移動
            local moveType = ply:GetMoveType()
            
            -- ボタン設定
            cmd:SetButtons(bit.bor(
                cmd:GetButtons(),
                g_VR.input.boolean_jump and IN_JUMP + IN_DUCK or 0,
                g_VR.input.boolean_sprint and IN_SPEED or 0,
                moveType == MOVETYPE_LADDER and IN_FORWARD or 0,
                (g_VR.tracking.hmd.pos.z < (g_VR.origin.z + convarValues.crouchThreshold)) and IN_DUCK or 0
            ))
            
            -- 視点角度設定
            local viewAngles = g_VR.currentvmi and g_VR.currentvmi.wrongMuzzleAng and 
                            g_VR.tracking.pose_righthand.ang or 
                            g_VR.viewModelMuzzle and g_VR.viewModelMuzzle.Ang or 
                            g_VR.tracking.hmd.ang
            
            viewAngles = viewAngles:Forward():Angle()
            cmd:SetViewAngles(viewAngles)
            
            -- NoClip移動
            if moveType == MOVETYPE_NOCLIP then
                cmd:SetForwardMove(math.abs(g_VR.input.vector2_walkdirection.y) > 0.5 and g_VR.input.vector2_walkdirection.y or 0)
                cmd:SetSideMove(math.abs(g_VR.input.vector2_walkdirection.x) > 0.5 and g_VR.input.vector2_walkdirection.x or 0)
                originVelocity = ply:GetVelocity()
                return
            end
            
            -- 通常移動（ジョイスティック）
            local joystickVec = LocalToWorld(
                Vector(
                    g_VR.input.vector2_walkdirection.y * math.abs(g_VR.input.vector2_walkdirection.y), 
                    (-g_VR.input.vector2_walkdirection.x) * math.abs(g_VR.input.vector2_walkdirection.x), 
                    0
                ) * ply:GetMaxSpeed() * 0.9, 
                Angle(0, 0, 0), 
                Vector(0, 0, 0), 
                Angle(
                    0, 
                    convarValues.controllerOriented and g_VR.tracking.pose_lefthand.ang.yaw or g_VR.tracking.hmd.ang.yaw, 
                    0
                )
            )
            
            local walkDirViewAngRelative = WorldToLocal(
                followVec + joystickVec, 
                zeroAng, 
                zeroVec, 
                Angle(0, viewAngles.yaw, 0)
            )
            
            cmd:SetForwardMove(walkDirViewAngRelative.x)
            cmd:SetSideMove(-walkDirViewAngRelative.y)
        end)
        
        -- デバッグコマンド
        concommand.Add("vrmod_debuglocomotion", function(ply, cmd, args)
            hook[args[1] == "1" and "Add" or "Remove"](
                "PostDrawTranslucentRenderables",
                "vrmod_playspaceviz",
                function(depth, sky)
                    if depth or sky then return end
                    
                    render.SetColorMaterial()
                    
                    -- プレイヤーボックス
                    render.DrawWireframeBox(
                        LocalPlayer():GetPos(), 
                        zeroAng, 
                        Vector(1, 1, 0) * -16, 
                        Vector(1, 1, 4.5) * 16, 
                        Color(255, 0, 0)
                    )
                    
                    -- プレイスペースボックス
                    render.DrawWireframeBox(
                        g_VR.origin, 
                        g_VR.originAngle, 
                        Vector(-200, -200, 0.1), 
                        Vector(200, 200, 200), 
                        Color(255, 255, 255), 
                        true
                    )
                    
                    -- グリッドライン
                    for i = 1, 4 do
                        render.DrawWireframeBox(
                            g_VR.origin, 
                            g_VR.originAngle, 
                            Vector(-200, -300 + i * 100, 0.1), 
                            Vector(200, -250 + i * 100, 0.1), 
                            Color(255, 255, 255), 
                            true
                        )
                        
                        render.DrawWireframeBox(
                            g_VR.origin, 
                            g_VR.originAngle, 
                            Vector(-300 + i * 100, -200, 0.1), 
                            Vector(-250 + i * 100, 200, 0.1), 
                            Color(255, 255, 255), 
                            true
                        )
                    end
                end
            )
        end)
    end

    -- ロコモーション停止
    local function stop()
        hook.Remove("CreateMove", "vrmod_locomotion")
        hook.Remove("PreRender", "vrmod_locomotion")
        hook.Remove("VRMod_PreRender", "teleport")
        
        if IsValid(tpBeamEnt) then 
            tpBeamEnt:Remove() 
        end
        
        vrmod.RemoveInGameMenuItem("Reset Vehicle View")
    end

    -- ロコモーション設定UI
    local function options(panel)
        -- コントローラー指向移動
        local controllerOrientedCheck = vgui.Create("DCheckBoxLabel")
        panel:Add(controllerOrientedCheck)
        controllerOrientedCheck:Dock(TOP)
        controllerOrientedCheck:DockMargin(5, 0, 0, 5)
        controllerOrientedCheck:SetDark(true)
        controllerOrientedCheck:SetText("Controller oriented locomotion")
        controllerOrientedCheck:SetChecked(convarValues.controllerOriented)
        
        function controllerOrientedCheck:OnChange(val)
            convars.vrmod_controlleroriented:SetBool(val)
        end
        
        -- スムーズターン
        local smoothTurnCheck = vgui.Create("DCheckBoxLabel")
        panel:Add(smoothTurnCheck)
        smoothTurnCheck:Dock(TOP)
        smoothTurnCheck:DockMargin(5, 0, 0, 0)
        smoothTurnCheck:SetDark(true)
        smoothTurnCheck:SetText("Smooth turning")
        smoothTurnCheck:SetChecked(convarValues.smoothTurn)
        
        function smoothTurnCheck:OnChange(val)
            convars.vrmod_smoothturn:SetBool(val)
        end
        
        -- スムーズターン速度
        local turnRateSlider = vgui.Create("DNumSlider")
        panel:Add(turnRateSlider)
        turnRateSlider:Dock(TOP)
        turnRateSlider:DockMargin(5, 0, 0, 5)
        turnRateSlider:SetMin(1)
        turnRateSlider:SetMax(360)
        turnRateSlider:SetDecimals(0)
        turnRateSlider:SetValue(convarValues.smoothTurnRate)
        turnRateSlider:SetDark(true)
        turnRateSlider:SetText("Smooth turn rate")
        
        function turnRateSlider:OnValueChanged(val)
            convars.vrmod_smoothturnrate:SetInt(val)
        end
    end

    -- 初期設定
    timer.Simple(0, function()
        vrmod.AddLocomotionOption("default", start, stop, options)
        
        vrmod.AddInGameMenuItem("Toggle Noclip", 2, 1, function()
            LocalPlayer():ConCommand("noclip")
        end)
    end)

-- vrmod_network.lua
    -- VRモジュールのネットワーク同期を提供

    g_VR = g_VR or {}
    local convars, convarValues = vrmod.GetConvars()
    vrmod.AddCallbackedConvar("vrmod_net_tickrate", nil, tostring(math.ceil(1/engine.TickInterval())), FCVAR_REPLICATED, nil, nil, nil, tonumber, nil)

    -- フレーム読み取り関数
    local function netReadFrame()
        local frame = {
            ts = net.ReadFloat(),
            characterYaw = net.ReadUInt(7) * 2.85714,
            finger1 = net.ReadUInt(7) / 100,
            finger2 = net.ReadUInt(7) / 100,
            finger3 = net.ReadUInt(7) / 100,
            finger4 = net.ReadUInt(7) / 100,
            finger5 = net.ReadUInt(7) / 100,
            finger6 = net.ReadUInt(7) / 100,
            finger7 = net.ReadUInt(7) / 100,
            finger8 = net.ReadUInt(7) / 100,
            finger9 = net.ReadUInt(7) / 100,
            finger10 = net.ReadUInt(7) / 100,
            hmdPos = net.ReadVector(),
            hmdAng = net.ReadAngle(),
            lefthandPos = net.ReadVector(),
            lefthandAng = net.ReadAngle(),
            righthandPos = net.ReadVector(),
            righthandAng = net.ReadAngle(),
        }
        
        if net.ReadBool() then
            frame.waistPos = net.ReadVector()
            frame.waistAng = net.ReadAngle()
            frame.leftfootPos = net.ReadVector()
            frame.leftfootAng = net.ReadAngle()
            frame.rightfootPos = net.ReadVector()
            frame.rightfootAng = net.ReadAngle()
        end
        
        return frame
    end

    -- クライアントフレーム構築
    local function buildClientFrame(relative)
        local frame = {
            characterYaw = LocalPlayer():InVehicle() and LocalPlayer():GetAngles().yaw or g_VR.characterYaw,
            hmdPos = g_VR.tracking.hmd.pos,
            hmdAng = g_VR.tracking.hmd.ang,
            lefthandPos = g_VR.tracking.pose_lefthand.pos,
            lefthandAng = g_VR.tracking.pose_lefthand.ang,
            righthandPos = g_VR.tracking.pose_righthand.pos,
            righthandAng = g_VR.tracking.pose_righthand.ang,
            finger1 = g_VR.input.skeleton_lefthand.fingerCurls[1],
            finger2 = g_VR.input.skeleton_lefthand.fingerCurls[2],
            finger3 = g_VR.input.skeleton_lefthand.fingerCurls[3],
            finger4 = g_VR.input.skeleton_lefthand.fingerCurls[4],
            finger5 = g_VR.input.skeleton_lefthand.fingerCurls[5],
            finger6 = g_VR.input.skeleton_righthand.fingerCurls[1],
            finger7 = g_VR.input.skeleton_righthand.fingerCurls[2],
            finger8 = g_VR.input.skeleton_righthand.fingerCurls[3],
            finger9 = g_VR.input.skeleton_righthand.fingerCurls[4],
            finger10 = g_VR.input.skeleton_righthand.fingerCurls[5],
        }
        
        if g_VR.sixPoints then
            frame.waistPos = g_VR.tracking.pose_waist.pos
            frame.waistAng = g_VR.tracking.pose_waist.ang
            frame.leftfootPos = g_VR.tracking.pose_leftfoot.pos
            frame.leftfootAng = g_VR.tracking.pose_leftfoot.ang
            frame.rightfootPos = g_VR.tracking.pose_rightfoot.pos
            frame.rightfootAng = g_VR.tracking.pose_rightfoot.ang
        end
        
        if relative then
            local plyPos = LocalPlayer():GetPos()
            local plyAng = LocalPlayer():InVehicle() and LocalPlayer():GetVehicle():GetAngles() or Angle()
            
            frame.hmdPos, frame.hmdAng = WorldToLocal(frame.hmdPos, frame.hmdAng, plyPos, plyAng)
            frame.lefthandPos, frame.lefthandAng = WorldToLocal(frame.lefthandPos, frame.lefthandAng, plyPos, plyAng)
            frame.righthandPos, frame.righthandAng = WorldToLocal(frame.righthandPos, frame.righthandAng, plyPos, plyAng)
            
            if g_VR.sixPoints then
                frame.waistPos, frame.waistAng = WorldToLocal(frame.waistPos, frame.waistAng, plyPos, plyAng)
                frame.leftfootPos, frame.leftfootAng = WorldToLocal(frame.leftfootPos, frame.leftfootAng, plyPos, plyAng)
                frame.rightfootPos, frame.rightfootAng = WorldToLocal(frame.rightfootPos, frame.rightfootAng, plyPos, plyAng)
            end
        end
        
        return frame
    end

    -- フレーム書き込み関数
    local function netWriteFrame(frame)
        net.WriteFloat(SysTime())
        
        local tmp = frame.characterYaw + math.ceil(math.abs(frame.characterYaw)/360) * 360 
        tmp = tmp - math.floor(tmp/360) * 360
        net.WriteUInt(frame.characterYaw * 0.35, 7) 
        
        net.WriteUInt(frame.finger1 * 100, 7)
        net.WriteUInt(frame.finger2 * 100, 7)
        net.WriteUInt(frame.finger3 * 100, 7)
        net.WriteUInt(frame.finger4 * 100, 7)
        net.WriteUInt(frame.finger5 * 100, 7)
        net.WriteUInt(frame.finger6 * 100, 7)
        net.WriteUInt(frame.finger7 * 100, 7)
        net.WriteUInt(frame.finger8 * 100, 7)
        net.WriteUInt(frame.finger9 * 100, 7)
        net.WriteUInt(frame.finger10 * 100, 7)
        
        net.WriteVector(frame.hmdPos)
        net.WriteAngle(frame.hmdAng)
        net.WriteVector(frame.lefthandPos)
        net.WriteAngle(frame.lefthandAng)
        net.WriteVector(frame.righthandPos)
        net.WriteAngle(frame.righthandAng)
        
        net.WriteBool(frame.waistPos ~= nil)
        
        if frame.waistPos then
            net.WriteVector(frame.waistPos)
            net.WriteAngle(frame.waistAng)
            net.WriteVector(frame.leftfootPos)
            net.WriteAngle(frame.leftfootAng)
            net.WriteVector(frame.rightfootPos)
            net.WriteAngle(frame.rightfootAng)
        end
    end

    if CLIENT then
        -- クライアント側のネットワーク設定
        vrmod.AddCallbackedConvar("vrmod_net_delay", nil, "0.1", nil, nil, nil, nil, tonumber, nil)
        vrmod.AddCallbackedConvar("vrmod_net_delaymax", nil, "0.2", nil, nil, nil, nil, tonumber, nil)
        vrmod.AddCallbackedConvar("vrmod_net_storedframes", nil, "15", nil, nil, nil, nil, tonumber, nil)
        
        g_VR.net = {
            -- Net構造例 
            -- ["steamid"] = {
            --     frames = { フレームの配列 },
            --     latestFrameIndex = 最新フレームのインデックス,
            --     lerpedFrame = 補間済みフレーム,
            --     playbackTime = 再生位置タイムスタンプ,
            --     sysTime = 現在の時間,
            --     buffering = バッファリング中か,
            --     debugState = デバッグ状態,
            --     debugNextFrame = 次のフレームインデックス,
            --     debugPreviousFrame = 前のフレームインデックス,
            --     debugFraction = 補間割合,
            --     characterAltHead = 代替頭部制御使用中か,
            --     dontHideBullets = 弾を隠さないか
            -- }
        }
        
        -- デバッグ用サンプルデータ
        g_VR.net["STEAM_0:1:47301228"] = {
            frames = {
                {ts = 1}, {ts = 2}, {ts = 3}, {ts = 4}, {ts = 5},
                {ts = 6}, {ts = 7}, {ts = 8}, {ts = 9.8}, {ts = 10},
            },
            playbackTime = 9,
            debugState = "buffering (reached end)",
            debugNextFrame = 2,
            debugPreviousFrame = 1,
            debugFraction = 0.5,
        }
        
        -- ネットワークデバッグ表示
        local debugToggle = false
        
        concommand.Add("vrmod_net_debug", function(ply, cmd, args)
            if debugToggle then
                hook.Remove("PostRender", "vrutil_netdebug")
                debugToggle = false
                return
            end
            
            debugToggle = true
            
            hook.Add("PostRender", "vrutil_netdebug", function()
                cam.Start2D()
                
                surface.SetFont("ChatFont")
                surface.SetTextColor(255, 255, 255)
                surface.SetTextPos(128, 100) 
                surface.DrawText("vrmod_net_debug")
                
                local leftSide, rightSide = 140, 628
                local verticalSpacing = 100
                local iply = 0
                
                for k, v in pairs(g_VR.net) do
                    if not v.playbackTime then
                        continue
                    end
                    
                    -- TPS計算
                    if SysTime() - (v.debugTpsT or 0) > 1 then
                        v.debugTpsT = SysTime()
                        v.debugTps = v.debugTickCount
                        v.debugTickCount = 0
                    end
                    
                    -- タイムスタンプ範囲計算
                    local mints, maxts = 9999999, 0
                    for i = 1, #v.frames do
                        mints = v.frames[i].ts < mints and v.frames[i].ts or mints
                        maxts = v.frames[i].ts > maxts and v.frames[i].ts or maxts
                    end
                    
                    -- 背景描画
                    surface.SetDrawColor(0, 0, 0, 200)
                    surface.DrawRect(128, 128 + iply * verticalSpacing, 512, 90)
                    
                    -- プレイヤー情報テキスト
                    surface.SetFont("ChatFont")
                    surface.SetTextColor(255, 255, 255)
                    surface.SetTextPos(140, 140 + iply * verticalSpacing) 
                    surface.DrawText(
                        k .. " | " .. v.debugState .. " | " .. 
                        (v.debugTps or 0) .. " | " .. 
                        math.floor((maxts - v.playbackTime) * 1000)
                    )
                    
                    -- フレームタイムライン（タイル表示）
                    surface.SetDrawColor(0, 0, 0, 200)
                    surface.DrawRect(leftSide, 160 + iply * verticalSpacing, rightSide - leftSide, 20)
                    
                    local tileWidth = (rightSide - leftSide) / #v.frames
                    
                    for i = 1, #v.frames do
                        local tsfraction = (v.frames[i].ts - mints) / (maxts - mints)
                        
                        surface.SetDrawColor(255 - tsfraction * 255, 0, tsfraction * 255, 255)
                        surface.DrawRect(
                            leftSide + tileWidth * (i - 1), 
                            160 + iply * verticalSpacing, 
                            2, 
                            20
                        )
                        
                        if i == v.debugPreviousFrame or i == v.debugNextFrame then
                            surface.SetDrawColor(0, 255, 0)
                            surface.DrawRect(
                                leftSide + tileWidth * (i - 1), 
                                160 + iply * verticalSpacing + (i == v.debugNextFrame and 18 or 0), 
                                2, 
                                2
                            )
                            
                            if i == v.debugPreviousFrame then
                                surface.DrawRect(
                                    leftSide + tileWidth * (i - 1 + v.debugFraction), 
                                    159 + iply * verticalSpacing, 
                                    2, 
                                    22
                                )
                            end
                        end
                    end
                    
                    -- フレームタイムライン（位置表示）
                    surface.SetDrawColor(0, 0, 0, 200)
                    surface.DrawRect(leftSide, 185 + iply * verticalSpacing, rightSide - leftSide, 20)
                    
                    for i = 1, #v.frames do
                        local tsfraction = (v.frames[i].ts - mints) / (maxts - mints)
                        
                        surface.SetDrawColor(255 - tsfraction * 255, 0, tsfraction * 255, 255)
                        surface.DrawRect(
                            leftSide + tsfraction * (rightSide - leftSide - 2), 
                            185 + iply * verticalSpacing, 
                            2, 
                            20
                        )
                    end
                    
                    -- 現在再生位置マーカー
                    surface.SetDrawColor(0, 255, 0, 255)
                    surface.DrawRect(
                        leftSide + ((v.playbackTime - mints) / (maxts - mints)) * (rightSide - leftSide - 2), 
                        185 + iply * verticalSpacing, 
                        2, 
                        20
                    )
                    
                    iply = iply + 1
                end
                
                cam.End2D()
            end)
        end)
        
        -- ネットワーク初期化
        function VRUtilNetworkInit() 
            -- 定期送信タイマー
            timer.Create("vrmod_transmit", 1 / convarValues.vrmod_net_tickrate, 0, function()
                if g_VR.threePoints then
                    net.Start("vrutil_net_tick", true)
                    net.WriteVector(g_VR.viewModelMuzzle and g_VR.viewModelMuzzle.Pos or Vector(0, 0, 0))
                    netWriteFrame(buildClientFrame(true))
                    net.SendToServer()
                end
            end)
            
            -- 参加通知
            net.Start("vrutil_net_join")
            net.WriteBool(GetConVar("vrmod_althead"):GetBool())
            net.WriteBool(GetConVar("vrmod_floatinghands"):GetBool())
            net.SendToServer()
        end
        
        -- 他プレイヤーVRポーズ補間
        local function LerpOtherVRPlayers()
            local lerpDelay = convarValues.vrmod_net_delay
            local lerpDelayMax = convarValues.vrmod_net_delaymax
            
            for k, v in pairs(g_VR.net) do
                local ply = player.GetBySteamID(k)
                
                if #v.frames < 2 or not ply then 
                    continue
                end
                
                -- バッファリング状態管理
                if v.buffering then
                    if not (v.playbackTime > v.frames[v.latestFrameIndex].ts - lerpDelay) then
                        v.buffering = false
                        v.sysTime = SysTime()
                        v.debugState = "playing"
                    end
                else
                    -- 再生時間更新
                    v.playbackTime = v.playbackTime + (SysTime() - v.sysTime)
                    v.sysTime = SysTime()
                    
                    -- 最新フレームを超えたらバッファリング
                    if v.playbackTime > v.frames[v.latestFrameIndex].ts then 
                        v.buffering = true
                        v.debugState = "buffering (reached end)"
                        v.playbackTime = v.frames[v.latestFrameIndex].ts
                    end
                    
                    -- 遅延が大きすぎる場合もバッファリング
                    if (v.frames[v.latestFrameIndex].ts - v.playbackTime) > lerpDelayMax then
                        v.buffering = true
                        v.playbackTime = v.frames[v.latestFrameIndex].ts
                        v.debugState = "buffering (catching up)"
                    end
                end
                
                -- 適切なフレーム間で補間
                for i = 1, #v.frames do
                    local nextFrame = i
                    local previousFrame = i - 1
                    
                    if previousFrame == 0 then
                        previousFrame = #v.frames
                    end
                    
                    if v.frames[nextFrame].ts >= v.playbackTime and v.frames[previousFrame].ts <= v.playbackTime then
                        local fraction = (v.playbackTime - v.frames[previousFrame].ts) / 
                                        (v.frames[nextFrame].ts - v.frames[previousFrame].ts)
                        
                        v.debugNextFrame = nextFrame
                        v.debugPreviousFrame = previousFrame
                        v.debugFraction = fraction
                        v.lerpedFrame = {}
                        
                        -- 補間処理
                        for k2, v2 in pairs(v.frames[previousFrame]) do
                            if k2 == "characterYaw" then
                                v.lerpedFrame[k2] = LerpAngle(
                                    fraction, 
                                    Angle(0, v2, 0), 
                                    Angle(0, v.frames[nextFrame][k2], 0)
                                ).yaw
                            elseif isnumber(v2) then
                                v.lerpedFrame[k2] = Lerp(fraction, v2, v.frames[nextFrame][k2])
                            elseif isvector(v2) then
                                v.lerpedFrame[k2] = LerpVector(fraction, v2, v.frames[nextFrame][k2])
                            elseif isangle(v2) then
                                v.lerpedFrame[k2] = LerpAngle(fraction, v2, v.frames[nextFrame][k2])
                            end
                        end
                        
                        -- ローカル→ワールド変換
                        local plyPos = ply:GetPos()
                        local plyAng = Angle()
                        
                        if ply:InVehicle() then
                            plyAng = ply:GetVehicle():GetAngles()
                            local _, forwardAng = LocalToWorld(
                                Vector(),
                                Angle(0, 90, 0),
                                Vector(), 
                                plyAng
                            )
                            v.lerpedFrame.characterYaw = forwardAng.yaw
                        end
                        
                        v.lerpedFrame.hmdPos, v.lerpedFrame.hmdAng = LocalToWorld(
                            v.lerpedFrame.hmdPos,
                            v.lerpedFrame.hmdAng,
                            plyPos,
                            plyAng
                        )
                        
                        v.lerpedFrame.lefthandPos, v.lerpedFrame.lefthandAng = LocalToWorld(
                            v.lerpedFrame.lefthandPos,
                            v.lerpedFrame.lefthandAng,
                            plyPos,
                            plyAng
                        )
                        
                        v.lerpedFrame.righthandPos, v.lerpedFrame.righthandAng = LocalToWorld(
                            v.lerpedFrame.righthandPos,
                            v.lerpedFrame.righthandAng,
                            plyPos,
                            plyAng
                        )
                        
                        if v.lerpedFrame.waistPos then
                            v.lerpedFrame.waistPos, v.lerpedFrame.waistAng = LocalToWorld(
                                v.lerpedFrame.waistPos,
                                v.lerpedFrame.waistAng,
                                plyPos,
                                plyAng
                            )
                            
                            v.lerpedFrame.leftfootPos, v.lerpedFrame.leftfootAng = LocalToWorld(
                                v.lerpedFrame.leftfootPos,
                                v.lerpedFrame.leftfootAng,
                                plyPos,
                                plyAng
                            )
                            
                            v.lerpedFrame.rightfootPos, v.lerpedFrame.rightfootAng = LocalToWorld(
                                v.lerpedFrame.rightfootPos,
                                v.lerpedFrame.rightfootAng,
                                plyPos,
                                plyAng
                            )
                        end
                        
                        break
                    end
                end
            end
        end
        
        -- ローカルプレイヤーVR状態更新
        function VRUtilNetUpdateLocalPly()
            local tab = g_VR.net[LocalPlayer():SteamID()]
            
            if g_VR.threePoints and tab then
                tab.lerpedFrame = buildClientFrame()
                return tab.lerpedFrame
            end
        end
        
        -- ネットワーク終了
        function VRUtilNetworkCleanup() 
            timer.Remove("vrmod_transmit")
            
            net.Start("vrutil_net_exit")
            net.SendToServer()
        end
        
        -- ネットワークメッセージ処理
        net.Receive("vrutil_net_tick", function(len)
            local ply = net.ReadEntity()
            if not IsValid(ply) then return end
            
            local tab = g_VR.net[ply:SteamID()]
            if not tab then return end
            
            tab.debugTickCount = tab.debugTickCount + 1
            
            local frame = netReadFrame()
            
            if tab.latestFrameIndex == 0 then
                tab.playbackTime = frame.ts
            elseif frame.ts <= tab.frames[tab.latestFrameIndex].ts then
                return
            end
            
            local index = tab.latestFrameIndex + 1
            if index > convarValues.vrmod_net_storedframes then
                index = 1
            end
            
            tab.frames[index] = frame
            tab.latestFrameIndex = index
        end)
        
        net.Receive("vrutil_net_join", function(len)
            local ply = net.ReadEntity()
            if not IsValid(ply) then return end 
            
            g_VR.net[ply:SteamID()] = {
                characterAltHead = net.ReadBool(),
                dontHideBullets = net.ReadBool(),
                frames = {},
                latestFrameIndex = 0,
                buffering = true,
                debugState = "buffering (initial)",
                debugTickCount = 0,
            }
            
            hook.Add("PreRender", "vrutil_hook_netlerp", LerpOtherVRPlayers)
            hook.Run("VRMod_Start", ply)
        end)
        
        -- 武器FOV記憶
        local swepOriginalFovs = {}
        
        net.Receive("vrutil_net_exit", function(len)
            local steamid = net.ReadString()
            
            if game.SinglePlayer() then
                steamid = LocalPlayer():SteamID()
            end
            
            local ply = player.GetBySteamID(steamid)
            g_VR.net[steamid] = nil
            
            if table.Count(g_VR.net) == 0 then
                hook.Remove("PreRender", "vrutil_hook_netlerp")
            end
            
            if ply == LocalPlayer() then
                for k, v in pairs(swepOriginalFovs) do
                    local wep = ply:GetWeapon(k)
                    if IsValid(wep) then
                        wep.ViewModelFOV = v
                    end
                end
                swepOriginalFovs = {}
            end
            
            hook.Run("VRMod_Exit", ply, steamid)
        end)
        
        -- 武器切り替え処理
        net.Receive("vrutil_net_switchweapon", function(len)
            local class = net.ReadString()
            local vm = net.ReadString()
            
            if class == "" or vm == "" or vm == "models/weapons/c_arms.mdl" then
                g_VR.viewModel = nil
                g_VR.openHandAngles = g_VR.defaultOpenHandAngles
                g_VR.closedHandAngles = g_VR.defaultClosedHandAngles
                g_VR.currentvmi = nil
                g_VR.viewModelMuzzle = nil
                return
            end
            
            if GetConVar("vrmod_useworldmodels"):GetBool() then
                vrmod.SetRightHandOpenFingerAngles(g_VR.zeroHandAngles)
                vrmod.SetRightHandClosedFingerAngles(g_VR.zeroHandAngles)
                
                timer.Create("vrutil_waitforwm", 0, 0, function()
                    if IsValid(LocalPlayer():GetActiveWeapon()) and 
                    LocalPlayer():GetActiveWeapon():GetClass() == class then
                        timer.Remove("vrutil_waitforwm")
                        g_VR.viewModel = LocalPlayer():GetActiveWeapon()
                    end
                end)
                
                return
            end
            
            local vmi = g_VR.viewModelInfo[class] or {}
            local model = vmi.modelOverride ~= nil and vmi.modelOverride or vm
            
            g_VR.viewModel = LocalPlayer():GetViewModel()
            local wep = LocalPlayer():GetActiveWeapon()
            
            if wep.ViewModelFOV then
                if not swepOriginalFovs[class] then
                    swepOriginalFovs[class] = wep.ViewModelFOV
                end
                wep.ViewModelFOV = GetConVar("fov_desired"):GetFloat()
            end
            
            if vmi.offsetPos == nil or vmi.offsetAng == nil then
                vmi.offsetPos, vmi.offsetAng = Vector(0, 0, 0), Angle(0, 0, 0)
                
                local cm = ClientsideModel(model)
                if IsValid(cm) then
                    cm:SetupBones()
                    local bone = cm:LookupBone("ValveBiped.Bip01_R_Hand")
                    
                    if bone then
                        local boneMat = cm:GetBoneMatrix(bone)
                        local bonePos, boneAng = boneMat:GetTranslation(), boneMat:GetAngles()
                        
                        boneAng:RotateAroundAxis(boneAng:Forward(), 180)
                        vmi.offsetPos, vmi.offsetAng = WorldToLocal(
                            Vector(0, 0, 0),
                            Angle(0, 0, 0),
                            bonePos,
                            boneAng
                        )
                        
                        vmi.offsetPos = vmi.offsetPos + g_VR.viewModelInfo.autoOffsetAddPos
                    end
                    
                    cm:Remove()
                end
            end
            
            vmi.closedHandAngles = vrmod.GetRightHandFingerAnglesFromModel(model)
            vrmod.SetRightHandClosedFingerAngles(vmi.closedHandAngles)
            vrmod.SetRightHandOpenFingerAngles(vmi.closedHandAngles)
            
            g_VR.viewModelInfo[class] = vmi
            g_VR.currentvmi = vmi
        end)
        
        -- 初期化後の自動開始
        hook.Add("CreateMove", "vrutil_hook_joincreatemove", function(cmd)
            hook.Remove("CreateMove", "vrutil_hook_joincreatemove")
            
            timer.Simple(2, function()
                net.Start("vrutil_net_requestvrplayers")
                net.SendToServer()
            end)
            
            timer.Simple(2, function()
                if SysTime() < 120 then
                    GetConVar("vrmod_autostart"):SetBool(false)
                end
                
                if GetConVar("vrmod_autostart"):GetBool() then
                    timer.Create("vrutil_timer_tryautostart", 1, 0, function()
                        local pm = LocalPlayer():GetModel()
                        if pm ~= nil and pm ~= "models/player.mdl" and pm ~= "" then
                            VRUtilClientStart()
                            timer.Remove("vrutil_timer_tryautostart")
                        end
                    end)
                end
            end)
        end)
        
        -- 車両関連メッセージ
        net.Receive("vrutil_net_entervehicle", function(len)
            hook.Call("VRMod_EnterVehicle", nil)
        end)
        
        net.Receive("vrutil_net_exitvehicle", function(len)
            hook.Call("VRMod_ExitVehicle", nil)
        end)
    elseif SERVER then
        -- サーバー側のネットワーク設定
        util.AddNetworkString("vrutil_net_join")
        util.AddNetworkString("vrutil_net_exit")
        util.AddNetworkString("vrutil_net_switchweapon")
        util.AddNetworkString("vrutil_net_tick")
        util.AddNetworkString("vrutil_net_requestvrplayers")
        util.AddNetworkString("vrutil_net_entervehicle")
        util.AddNetworkString("vrutil_net_exitvehicle")
        
        -- ティック情報受信
        vrmod.NetReceiveLimited("vrutil_net_tick", convarValues.vrmod_net_tickrate + 5, 1200, function(len, ply)
            if g_VR[ply:SteamID()] == nil then
                return
            end
            
            local viewHackPos = net.ReadVector()
            local frame = netReadFrame()
            
            g_VR[ply:SteamID()].latestFrame = frame
            
            if not viewHackPos:IsZero() and util.IsInWorld(viewHackPos) then
                ply.viewOffset = viewHackPos - ply:EyePos() + ply.viewOffset
                ply:SetCurrentViewOffset(ply.viewOffset)
                ply:SetViewOffset(Vector(0, 0, ply.viewOffset.z))
            else
                ply:SetCurrentViewOffset(ply.originalViewOffset)
                ply:SetViewOffset(ply.originalViewOffset)
            end
            
            net.Start("vrutil_net_tick", true)
            net.WriteEntity(ply)
            netWriteFrame(frame)
            net.SendOmit(ply)
        end)
        
        -- 参加情報受信
        vrmod.NetReceiveLimited("vrutil_net_join", 5, 2, function(len, ply)
            if g_VR[ply:SteamID()] ~= nil then 
                return 
            end
            
            ply:DrawShadow(false)
            ply.originalViewOffset = ply:GetViewOffset()
            ply.viewOffset = Vector(0, 0, 0)
            
            g_VR[ply:SteamID()] = {
                characterAltHead = net.ReadBool(),
                dontHideBullets = net.ReadBool(),
            }
            
            ply:Give("weapon_vrmod_empty")
            ply:SelectWeapon("weapon_vrmod_empty")
            
            local omittedPlayers = {}
            for k, v in ipairs(player.GetAll()) do
                if not v.hasRequestedVRPlayers then
                    omittedPlayers[#omittedPlayers + 1] = v
                end
            end
            
            net.Start("vrutil_net_join")
            net.WriteEntity(ply)
            net.WriteBool(g_VR[ply:SteamID()].characterAltHead)
            net.WriteBool(g_VR[ply:SteamID()].dontHideBullets)
            net.SendOmit(omittedPlayers)
            
            hook.Run("VRMod_Start", ply)
        end)
        
        -- 退出処理
        local function net_exit(steamid)
            if g_VR[steamid] ~= nil then
                g_VR[steamid] = nil
                
                local ply = player.GetBySteamID(steamid)
                ply:SetCurrentViewOffset(ply.originalViewOffset)
                ply:SetViewOffset(ply.originalViewOffset)
                ply:StripWeapon("weapon_vrmod_empty")
                
                net.Start("vrutil_net_exit")
                net.WriteString(steamid)
                net.Broadcast()
                
                hook.Run("VRMod_Exit", ply)
            end
        end
        
        -- 退出情報受信
        vrmod.NetReceiveLimited("vrutil_net_exit", 5, 0, function(len, ply)
            net_exit(ply:SteamID())
        end)
        
        -- プレイヤー切断時の退出処理
        hook.Add("PlayerDisconnected", "vrutil_hook_playerdisconnected", function(ply)
            net_exit(ply:SteamID())
        end)
        
        -- VRプレイヤー情報要求
        vrmod.NetReceiveLimited("vrutil_net_requestvrplayers", 5, 0, function(len, ply)
            ply.hasRequestedVRPlayers = true
            
            for k, v in pairs(g_VR) do
                local vrPly = player.GetBySteamID(k)
                
                if IsValid(vrPly) then
                    net.Start("vrutil_net_join")
                    net.WriteEntity(vrPly)
                    net.WriteBool(g_VR[k].characterAltHead)
                    net.WriteBool(g_VR[k].dontHideBullets)
                    net.Send(ply)
                else
                    print("VRMod: Invalid SteamID \"" .. k .. "\" found in player table")
                end
            end
        end)
        
        -- プレイヤー死亡時の処理
        hook.Add("PlayerDeath", "vrutil_hook_playerdeath", function(ply, inflictor, attacker)
            if g_VR[ply:SteamID()] ~= nil then
                net.Start("vrutil_net_exit")
                net.WriteString(ply:SteamID())
                net.Broadcast()
            end
        end)
        
        -- プレイヤースポーン時の処理
        hook.Add("PlayerSpawn", "vrutil_hook_playerspawn", function(ply)
            if g_VR[ply:SteamID()] ~= nil then
                ply:Give("weapon_vrmod_empty")
                
                net.Start("vrutil_net_join")
                net.WriteEntity(ply)
                net.WriteBool(g_VR[ply:SteamID()].characterAltHead)
                net.WriteBool(g_VR[ply:SteamID()].dontHideBullets)
                net.Broadcast()
            end
        end)
        
        -- 武器切り替え時の処理
        hook.Add("PlayerSwitchWeapon", "vrutil_hook_playerswitchweapon", function(ply, old, new)
            if g_VR[ply:SteamID()] ~= nil then
                net.Start("vrutil_net_switchweapon")
                
                if IsValid(new) then
                    net.WriteString(new:GetClass())
                    net.WriteString(new:GetWeaponViewModel())
                else
                    net.WriteString("")
                    net.WriteString("")
                end
                
                net.Send(ply)
                
                timer.Simple(0, function() end)
            end
        end)
        
        -- 車両乗車時の処理
        hook.Add("PlayerEnteredVehicle", "vrutil_hook_playerenteredvehicle", function(ply, veh)
            if g_VR[ply:SteamID()] ~= nil then
                ply:SelectWeapon("weapon_vrmod_empty")
                ply:SetActiveWeapon(ply:GetWeapon("weapon_vrmod_empty"))
                
                net.Start("vrutil_net_entervehicle")
                net.Send(ply)
            end
        end)
        
        -- 車両から降りる時の処理
        hook.Add("PlayerLeaveVehicle", "vrutil_hook_playerleavevehicle", function(ply, veh)
            if g_VR[ply:SteamID()] ~= nil then
                net.Start("vrutil_net_exitvehicle")
                net.Send(ply)
            end
        end)
    end

-- vrmod_ui.lua
    -- VRメニューシステムの基本要素を提供

    if CLIENT then
        g_VR = g_VR or {}
        g_VR.menuFocus = false
        g_VR.menuCursorX = 0
        g_VR.menuCursorY = 0
        
        -- ビームレンダーターゲット
        local rt_beam = GetRenderTarget("vrmod_rt_beam", 64, 64, false)
        local mat_beam = CreateMaterial(
            "vrmod_mat_beam",
            "UnlitGeneric",
            {
                ["$basetexture"] = rt_beam:GetName()
            }
        )
        
        render.PushRenderTarget(rt_beam)
        render.Clear(0, 0, 255, 255)
        render.PopRenderTarget()
        
        -- メニュー管理
        g_VR.menus = {}
        local menus = g_VR.menus
        local menuOrder = {}
        local menusExist = false
        local prevFocusPanel = nil
        
        -- パネル描画関数
        function VRUtilMenuRenderPanel(uid)
            timer.Simple(0.1, function()
                if menus[uid] == nil or 
                menus[uid].panel == nil or 
                not menus[uid].panel:IsValid() then 
                    return 
                end
                
                render.PushRenderTarget(menus[uid].rt)
                cam.Start2D()
                render.ClearDepth()
                render.Clear(0, 0, 0, 0)
                menus[uid].panel:PaintManual()
                cam.End2D()
                render.PopRenderTarget()
            end)
        end
        
        -- メニュー描画関数
        function VRUtilMenuRenderStart(uid)
            render.PushRenderTarget(menus[uid].rt)
            cam.Start2D()
            render.ClearDepth()
            render.Clear(0, 0, 0, 0)
        end
        
        function VRUtilMenuRenderEnd()
            cam.End2D()
            render.PopRenderTarget()
        end
        
        -- メニューステータス確認
        function VRUtilIsMenuOpen(uid)
            return menus[uid] ~= nil
        end
        
        -- メニューシステム描画
        function VRUtilRenderMenuSystem()
            if menusExist == false then return end
            
            render.DepthRange(0, 0.001)
            g_VR.menuFocus = false
            
            local menuFocusDist = 99999
            local menuFocusPanel = nil
            local menuFocusCursorWorldPos = nil
            
            -- トーンマッピング調整
            local tms = render.GetToneMappingScaleLinear()
            render.SetToneMappingScaleLinear(
                g_VR.view.dopostprocess and 
                Vector(0.75, 0.75, 0.75) or 
                Vector(1, 1, 1)
            )
            
            -- メニュー描画
            for k, v in ipairs(menuOrder) do
                k = v.uid
                
                if v.panel then
                    if not IsValid(v.panel) or not v.panel:IsVisible() then
                        VRUtilMenuClose(k)
                        continue
                    end
                end
                
                -- 位置と角度の計算
                local pos, ang = v.pos, v.ang
                
                if v.attachment == 1 then
                    pos, ang = LocalToWorld(pos, ang, g_VR.tracking.pose_lefthand.pos, g_VR.tracking.pose_lefthand.ang)
                elseif v.attachment == 2 then
                    pos, ang = LocalToWorld(pos, ang, g_VR.tracking.pose_righthand.pos, g_VR.tracking.pose_righthand.ang)
                elseif v.attachment == 3 then
                    pos, ang = LocalToWorld(pos, ang, g_VR.tracking.hmd.pos, g_VR.tracking.hmd.ang)
                elseif v.attachment == 4 then
                    pos, ang = LocalToWorld(pos, ang, g_VR.origin, g_VR.originAngle)
                end
                
                -- メニュー描画
                cam.Start3D2D(pos, ang, v.scale)
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(v.mat)
                surface.DrawTexturedRect(0, 0, v.width, v.height)
                cam.End3D2D()
                
                -- カーソル処理
                if v.cursorEnabled then
                    local cursorX, cursorY = -1, -1
                    local cursorWorldPos = Vector(0, 0, 0)
                    local start = g_VR.tracking.pose_righthand.pos
                    local dir = g_VR.tracking.pose_righthand.ang:Forward()
                    local dist = nil
                    local normal = ang:Up()
                    local A = normal:Dot(dir)
                    
                    if A < 0 then
                        local B = normal:Dot(pos - start)
                        
                        if B < 0 then
                            dist = B / A
                            cursorWorldPos = start + dir * dist
                            
                            local tp, unused = WorldToLocal(cursorWorldPos, Angle(0, 0, 0), pos, ang)
                            cursorX = tp.x * (1 / v.scale)
                            cursorY = -tp.y * (1 / v.scale)
                        end
                    end
                    
                    if cursorX > 0 and 
                    cursorY > 0 and 
                    cursorX < v.width and 
                    cursorY < v.height and 
                    dist < menuFocusDist then
                        g_VR.menuFocus = k
                        g_VR.menuCursorX = cursorX
                        g_VR.menuCursorY = cursorY
                        menuFocusDist = dist
                        menuFocusPanel = v.panel
                        menuFocusCursorWorldPos = cursorWorldPos
                    end
                end
            end
            
            render.SetToneMappingScaleLinear(tms)
            
            -- パネルフォーカス変更処理
            if menuFocusPanel ~= prevFocusPanel then
                if IsValid(prevFocusPanel) then
                    prevFocusPanel:SetMouseInputEnabled(false)
                end
                
                if IsValid(menuFocusPanel) then
                    menuFocusPanel:SetMouseInputEnabled(true)
                end
                
                gui.EnableScreenClicker(menuFocusPanel ~= nil)
                prevFocusPanel = menuFocusPanel
            end
            
            -- カーソルビーム描画
            if g_VR.menuFocus then
                render.SetMaterial(mat_beam)
                render.DrawBeam(
                    g_VR.tracking.pose_righthand.pos, 
                    menuFocusCursorWorldPos, 
                    0.1, 0, 0, 
                    Color(255, 255, 255, 255)
                )
                
                input.SetCursorPos(g_VR.menuCursorX, g_VR.menuCursorY)
            end
            
            render.DepthRange(0, 1)
        end
        
        -- メニュー作成
        function VRUtilMenuOpen(uid, width, height, panel, attachment, pos, ang, scale, cursorEnabled, closeFunc)
            if menus[uid] then return end
            
            menus[uid] = {
                uid = uid,
                panel = panel,
                closeFunc = closeFunc,
                attachment = attachment,
                pos = pos,
                ang = ang,
                scale = scale,
                cursorEnabled = cursorEnabled,
                rt = GetRenderTarget("vrmod_rt_ui_" .. uid, width, height, false),
                width = width,
                height = height,
            }
            
            menuOrder[#menuOrder + 1] = menus[uid]
            
            local mat = Material("!vrmod_mat_ui_" .. uid)
            menus[uid].mat = not mat:IsError() and mat or CreateMaterial(
                "vrmod_mat_ui_" .. uid,
                "UnlitGeneric",
                {
                    ["$basetexture"] = menus[uid].rt:GetName(),
                    ["$translucent"] = 1
                }
            )
            
            if panel then
                panel:SetPaintedManually(true)
                VRUtilMenuRenderPanel(uid)
            end
            
            render.PushRenderTarget(menus[uid].rt)
            render.Clear(0, 0, 0, 0)
            render.PopRenderTarget()
            
            if GetConVar("vrmod_useworldmodels"):GetBool() then
                hook.Add(
                    "PostDrawTranslucentRenderables",
                    "vrutil_hook_drawmenus",
                    function(bDrawingDepth, bDrawingSkybox)
                        if bDrawingSkybox then return end
                        VRUtilRenderMenuSystem()
                    end
                )
            end
            
            menusExist = true
        end
        
        -- メニュー閉じる
        function VRUtilMenuClose(uid)
            for k, v in pairs(menus) do
                if k == uid or not uid then
                    if IsValid(v.panel) then
                        v.panel:SetPaintedManually(false)
                    end
                    
                    if v.closeFunc then
                        v.closeFunc()
                    end
                    
                    for k2, v2 in ipairs(menuOrder) do
                        if v2 == v then
                            table.remove(menuOrder, k2)
                            break
                        end
                    end
                    
                    menus[k] = nil
                end
            end
            
            if table.Count(menus) == 0 then
                hook.Remove("PostDrawTranslucentRenderables", "vrutil_hook_drawmenus")
                g_VR.menuFocus = false
                menusExist = false
                gui.EnableScreenClicker(false)
            end
        end
        
        -- メニュー入力処理
        hook.Add("VRMod_Input", "ui", function(action, pressed)
            if g_VR.menuFocus and action == "boolean_primaryfire" then
                if pressed then
                    gui.InternalMousePressed(MOUSE_LEFT)
                else
                    gui.InternalMouseReleased(MOUSE_LEFT)
                end
                
                VRUtilMenuRenderPanel(g_VR.menuFocus)
            end
        end)
    end

-- vrmod_menu.lua
    -- VRモジュールのメニューシステム

    if SERVER then return end

    -- フォント定義
    surface.CreateFont(
        "vrmod_Trebuchet24",
        {
            font = "Trebuchet MS",
            size = 24,
            weight = 100
        }
    )

    -- メニュー管理
    local frame = nil

    -- メニューオープン
    local function OpenMenu()
        if IsValid(frame) then return frame end
        
        frame = vgui.Create("DFrame")
        frame:SetSize(400, 485)
        frame:SetTitle("VRMod Menu")
        frame:MakePopup()
        frame:Center()
        
        -- エラーがある場合の処理
        local error = vrmod.GetStartupError()
        if error and error ~= "Already running" then
            local tmp = vgui.Create("DLabel", frame)
            tmp:SetText(error)
            tmp:SetWrap(true)
            tmp:SetSize(250, 100)
            tmp:SetAutoStretchVertical(true)
            tmp:SetFont("vrmod_Trebuchet24") 
            
            function tmp:PerformLayout()
                tmp:Center()
            end
            
            return frame
        end
        
        -- 通常のメニュー構築
        local sheet = vgui.Create("DPropertySheet", frame)
        sheet:SetPadding(1)
        sheet:Dock(FILL)
        frame.DPropertySheet = sheet
        
        local panel1 = vgui.Create("DPanel", sheet)
        sheet:AddSheet("Settings", panel1)
        
        local scrollPanel = vgui.Create("DScrollPanel", panel1)
        scrollPanel:Dock(FILL)
        
        local form = vgui.Create("DForm", scrollPanel)
        form:SetName("Settings")
        form:Dock(TOP)
        form.Header:SetVisible(false)
        form.Paint = function(self, w, h) end
        frame.SettingsForm = form
        
        -- 下部パネル
        local bottomPanel = vgui.Create("DPanel", frame)
        bottomPanel:Dock(BOTTOM)
        bottomPanel:SetTall(35)
        bottomPanel.Paint = function(self, w, h) end
        
        -- バージョン情報
        local versionInfo = vgui.Create("DLabel", bottomPanel)
        versionInfo:SetText("Addon version: " .. vrmod.GetVersion() .. 
                            "\nModule version: " .. vrmod.GetModuleVersion())
        versionInfo:SizeToContents()
        versionInfo:SetPos(5, 5)
        
        -- 終了ボタン
        local exitButton = vgui.Create("DButton", bottomPanel)
        exitButton:SetText("Exit")
        exitButton:Dock(RIGHT)
        exitButton:DockMargin(0, 5, 0, 0)
        exitButton:SetWide(96)
        exitButton:SetEnabled(g_VR.active)
        
        function exitButton:DoClick()
            frame:Remove()
            VRUtilClientExit()
        end
        
        -- 起動/再起動ボタン
        local startButton = vgui.Create("DButton", bottomPanel)
        startButton:SetText(g_VR.active and "Restart" or "Start")
        startButton:Dock(RIGHT)
        startButton:DockMargin(0, 5, 5, 0)
        startButton:SetWide(96)
        
        function startButton:DoClick()
            frame:Remove()
            
            if g_VR.active then
                VRUtilClientExit()
                
                timer.Simple(1, function()
                    VRUtilClientStart()
                end)
            else
                VRUtilClientStart()
            end
        end
        
        -- フックからのコンテンツ追加
        if not error or error == "Already running" then
            local hooks = hook.GetTable().VRMod_Menu
            local names = {}
            
            for k, v in pairs(hooks) do
                names[#names + 1] = k
            end
            
            table.sort(names)
            
            for k, v in ipairs(names) do
                hooks[v](frame)
            end
        end
        
        return frame
    end

    -- コマンド登録
    concommand.Add("vrmod", function(ply, cmd, args)
        if vgui.CursorVisible() then
            print("vrmod: menu will open when game is unpaused")
        end
        
        timer.Create("vrmod_open_menu", 0.1, 0, function()
            if not vgui.CursorVisible() then
                OpenMenu()
                timer.Remove("vrmod_open_menu")
            end
        end)
    end)

    -- 自動表示設定
    local convars = vrmod.AddCallbackedConvar("vrmod_showonstartup", nil, "0")

    if convars.vrmod_showonstartup:GetBool() then
        hook.Add("CreateMove", "vrmod_showonstartup", function()
            hook.Remove("CreateMove", "vrmod_showonstartup")
            
            timer.Simple(1, function()
                RunConsoleCommand("vrmod")
            end)
        end)
    end

    -- メニューアイテム追加
    vrmod.AddInGameMenuItem("Settings", 4, 0, function()
        OpenMenu()
        
        hook.Add("VRMod_OpenQuickMenu", "closesettings", function()
            hook.Remove("VRMod_OpenQuickMenu", "closesettings")
            
            if IsValid(frame) then
                frame:Remove()
                frame = nil
                return false
            end
        end)
    end)

-- vrmod_ui_quickmenu.lua
    -- VRでのクイックメニュー

    if SERVER then return end

    local open = false

    -- メニューを開く
    function g_VR.MenuOpen()
        if hook.Call("VRMod_OpenQuickMenu") == false then return end
        if open then return end
        
        open = true
        
        -- アイテムのソート
        local items = {}
        
        for k, v in pairs(g_VR.menuItems) do
            local slot, slotPos = v.slot, v.slotPos
            local index = #items + 1
            
            for i = 1, #items do
                if items[i].slot > slot or (items[i].slot == slot and items[i].slotPos > slotPos) then
                    index = i
                    break
                end
            end
            
            table.insert(items, index, {
                index = k,
                slot = slot,
                slotPos = slotPos
            })
        end
        
        -- アイテムの位置計算
        local currentSlot, actualSlotPos = 0, 0
        
        for i = 1, #items do
            if items[i].slot ~= currentSlot then
                actualSlotPos = 0
                currentSlot = items[i].slot
            end
            
            items[i].actualSlotPos = actualSlotPos
            actualSlotPos = actualSlotPos + 1
        end
        
        local prevHoveredItem = -2
        local ply = LocalPlayer()
        local renderCount = 0
        
        -- メニュー位置・角度の計算
        local tmp = Angle(0, g_VR.tracking.hmd.ang.yaw - 90, 60) 
        local pos, ang = WorldToLocal(
            g_VR.tracking.pose_righthand.pos + 
            g_VR.tracking.pose_righthand.ang:Forward() * 9 + 
            tmp:Right() * -7.68 + 
            tmp:Forward() * -6.45, 
            tmp, 
            g_VR.origin, 
            g_VR.originAngle
        )
        
        -- メニュー作成
        VRUtilMenuOpen(
            "miscmenu",
            512,
            512,
            nil,
            4,
            pos,
            ang,
            0.03,
            true,
            function()
                hook.Remove("PreRender", "vrutil_hook_renderigm")
                open = false
                
                -- 選択されたアイテムの実行
                if items[prevHoveredItem] and g_VR.menuItems[items[prevHoveredItem].index] then
                    g_VR.menuItems[items[prevHoveredItem].index].func()
                end
            end
        )
        
        -- メニュー描画
        hook.Add("PreRender", "vrutil_hook_renderigm", function()
            hoveredItem = -1
            local hoveredSlot, hoveredSlotPos = -1, -1
            
            if g_VR.menuFocus == "miscmenu" then
                hoveredSlot = math.floor(g_VR.menuCursorX / 86)
                hoveredSlotPos = math.floor((g_VR.menuCursorY - 230) / 57)
            end
            
            for i = 1, #items do
                if items[i].slot == hoveredSlot and items[i].actualSlotPos == hoveredSlotPos then
                    hoveredItem = i
                    break
                end
            end
            
            local changes = hoveredItem ~= prevHoveredItem
            prevHoveredItem = hoveredItem
            
            if not changes then return end
            
            VRUtilMenuRenderStart("miscmenu")
            
            local buttonWidth, buttonHeight = 82, 53
            local gap = (512 - buttonWidth * 6) / 5
            
            for i = 1, #items do
                local x, y = items[i].slot, items[i].actualSlotPos
                
                draw.RoundedBox(
                    8, 
                    x * (buttonWidth + gap), 
                    230 + y * (buttonHeight + gap), 
                    buttonWidth, 
                    buttonHeight, 
                    Color(0, 0, 0, hoveredItem == i and 200 or 128)
                )
                
                local explosion = string.Explode(" ", g_VR.menuItems[items[i].index].name, false)
                
                for j = 1, #explosion do
                    draw.SimpleText(
                        explosion[j], 
                        "HudSelectionText", 
                        buttonWidth / 2 + x * (buttonWidth + gap), 
                        230 + buttonHeight / 2 + y * (buttonHeight + gap) - (#explosion * 6 - 6 - (j - 1) * 12), 
                        Color(255, 255, 255, 255), 
                        TEXT_ALIGN_CENTER, 
                        TEXT_ALIGN_CENTER
                    )
                end
            end
            
            VRUtilMenuRenderEnd()
        end)
    end

    -- メニューを閉じる
    function g_VR.MenuClose()
        VRUtilMenuClose("miscmenu")
    end

-- vrmod_ui_weaponselect.lua
    -- VRでの武器選択メニュー

    if SERVER then return end

    -- フォント定義
    surface.CreateFont(
        "vrmod_HalfLife2",
        {
            font = "HalfLife2",
            extended = false,
            size = 50,
            weight = 0,
            blursize = 0,
            scanlines = 0,
            antialias = true,
        }
    )

    surface.CreateFont(
        "vrmod_HalfLife2Small",
        {
            font = "HalfLife2",
            extended = false,
            size = 25,
            weight = 0,
            blursize = 0,
            scanlines = 0,
            antialias = true,
        }
    )

    surface.CreateFont(
        "vrmod_Verdana37",
        {
            font = "Verdana",
            size = 37,
            weight = 600,
            antialias = true,
        }
    )

    -- メニュー状態
    local open = false

    -- 武器選択メニューを開く
    function VRUtilWeaponMenuOpen()
        if open then return end
        open = true
        
        -- アイテムの準備
        local items = {}
        
        -- 武器アイコンのオーバーライド
        local overrides = {
            weapon_smg1 = {
                label = "a",
                font = "vrmod_HalfLife2"
            },
            weapon_shotgun = {
                label = "b",
                font = "vrmod_HalfLife2"
            },
            weapon_crowbar = {
                label = "c",
                font = "vrmod_HalfLife2"
            },
            weapon_pistol = {
                label = "d",
                font = "vrmod_HalfLife2"
            },
            weapon_357 = {
                label = "e",
                font = "vrmod_HalfLife2"
            },
            weapon_crossbow = {
                label = "g",
                font = "vrmod_HalfLife2"
            },
            weapon_physgun = {
                label = "h",
                font = "vrmod_HalfLife2"
            },
            weapon_rpg = {
                label = "i",
                font = "vrmod_HalfLife2"
            },
            weapon_bugbait = {
                label = "j",
                font = "vrmod_HalfLife2"
            },
            weapon_frag = {
                label = "k",
                font = "vrmod_HalfLife2"
            },
            weapon_ar2 = {
                label = "l",
                font = "vrmod_HalfLife2"
            },
            weapon_physcannon = {
                label = "m",
                font = "vrmod_HalfLife2"
            },
            weapon_stunstick = {
                label = "n",
                font = "vrmod_HalfLife2"
            },
            weapon_slam = {
                label = "o",
                font = "vrmod_HalfLife2"
            },
        }
        
        -- 武器アイテムの構築
        for k, v in pairs(LocalPlayer():GetWeapons()) do
            local slot, slotPos = v:GetSlot(), v:GetSlotPos()
            local index = #items + 1
            
            for i = 1, #items do
                if items[i].slot > slot or (items[i].slot == slot and items[i].slotPos > slotPos) then
                    index = i
                    break
                end
            end
            
            table.insert(items, index, {
                title = v:GetPrintName(),
                label = language.GetPhrase(
                    overrides[v:GetClass()] == nil and 
                    v:GetPrintName() or 
                    overrides[v:GetClass()].label
                ),
                font = overrides[v:GetClass()] == nil and 
                    "HudSelectionText" or 
                    overrides[v:GetClass()].font,
                wep = v,
                slot = slot,
                slotPos = slotPos
            })
        }
        
        -- アイテムのスロット位置計算
        local currentSlot, actualSlotPos = 0, 0
        
        for i = 1, #items do
            if items[i].slot ~= currentSlot then
                actualSlotPos = 0
                currentSlot = items[i].slot
            end
            
            items[i].actualSlotPos = actualSlotPos
            actualSlotPos = actualSlotPos + 1
        end
        
        -- 状態変数
        local prevValues = {
            hoveredItem = -1,
            health = -1,
            suit = -1,
            clip = -1,
            total = -1,
            alt = -1
        }
        
        local ply = LocalPlayer()
        local renderCount = 0
        
        -- メニュー位置・角度の計算
        local tmp = Angle(0, g_VR.tracking.hmd.ang.yaw - 90, 45) 
        local pos, ang = WorldToLocal(
            g_VR.tracking.pose_righthand.pos + 
            tmp:Forward() * -9 + 
            tmp:Right() * -11 + 
            tmp:Up() * -7, 
            tmp, 
            g_VR.origin, 
            g_VR.originAngle
        )
        
        -- メニュー作成
        VRUtilMenuOpen(
            "weaponmenu",
            512,
            512,
            nil,
            4,
            pos,
            ang,
            0.03,
            true,
            function()
                hook.Remove("PreRender", "vrutil_hook_renderweaponselect")
                open = false
                
                -- 選択された武器に切り替え
                if items[prevValues.hoveredItem] and IsValid(items[prevValues.hoveredItem].wep) then
                    input.SelectWeapon(items[prevValues.hoveredItem].wep)
                end
            end
        )
        
        -- メニュー描画
        hook.Add("PreRender", "vrutil_hook_renderweaponselect", function()
            local values = {}
            values.hoveredItem = -1
            
            -- ホバー位置の計算
            local hoveredSlot, hoveredSlotPos = -1, -1
            
            if g_VR.menuFocus == "weaponmenu" then
                hoveredSlot = math.floor(g_VR.menuCursorX / 86)
                hoveredSlotPos = math.floor((g_VR.menuCursorY - 114) / 57)
            end
            
            for i = 1, #items do
                if items[i].slot == hoveredSlot and items[i].actualSlotPos == hoveredSlotPos then
                    values.hoveredItem = i
                    break
                end
            end
            
            -- 状態情報の更新
            values.health, values.suit = ply:Health(), ply:Armor()
            values.clip, values.total, values.alt = 0, 0, 0
            
            local wep = ply:GetActiveWeapon()
            if IsValid(wep) then
                values.clip = wep:Clip1()
                values.total = ply:GetAmmoCount(wep:GetPrimaryAmmoType())
                values.alt = ply:GetAmmoCount(wep:GetSecondaryAmmoType())
            end
            
            -- 変更確認
            local changes = false
            
            for k, v in pairs(values) do
                if v ~= prevValues[k] then
                    changes = true
                    break
                end
            end
            
            prevValues = values
            
            if not changes then return end
            
            -- メニュー描画開始
            VRUtilMenuRenderStart("weaponmenu")
            
            -- 健康状態表示
            draw.RoundedBox(8, 0, 0, 145, 53, Color(0, 0, 0, 128))
            draw.SimpleText(
                "HEALTH", 
                "HudSelectionText", 
                10, 45, 
                Color(255, values.health > 19 and 250 or 0, 0, 255), 
                TEXT_ALIGN_LEFT, 
                TEXT_ALIGN_BOTTOM
            )
            draw.SimpleText(
                values.health, 
                "vrmod_HalfLife2", 
                140, 50, 
                Color(255, values.health > 19 and 250 or 0, 0, 255), 
                TEXT_ALIGN_RIGHT, 
                TEXT_ALIGN_BOTTOM
            )
            
            -- スーツ表示
            draw.RoundedBox(8, 149, 0, 130, 53, Color(0, 0, 0, 128))
            draw.SimpleText(
                "SUIT", 
                "HudSelectionText", 
                165, 45, 
                Color(255, 250, 0, 255), 
                TEXT_ALIGN_LEFT, 
                TEXT_ALIGN_BOTTOM
            )
            draw.SimpleText(
                values.suit, 
                "vrmod_HalfLife2", 
                270, 50, 
                Color(255, 250, 0, 255), 
                TEXT_ALIGN_RIGHT, 
                TEXT_ALIGN_BOTTOM
            )
            
            -- 弾薬表示
            draw.RoundedBox(8, 283, 0, 150, 53, Color(0, 0, 0, 128))
            draw.SimpleText(
                "AMMO", 
                "HudSelectionText", 
                290, 45, 
                Color(255, values.clip == 0 and 0 or 250, 0, 255), 
                TEXT_ALIGN_LEFT, 
                TEXT_ALIGN_BOTTOM
            )
            draw.SimpleText(
                values.clip, 
                "vrmod_HalfLife2", 
                338, 50, 
                Color(255, values.clip == 0 and 0 or 250, 0, 255), 
                TEXT_ALIGN_LEFT, 
                TEXT_ALIGN_BOTTOM
            )
            draw.SimpleText(
                values.total, 
                "vrmod_HalfLife2Small", 
                429, 47, 
                Color(255, values.clip == 0 and 0 or 250, 0, 255), 
                TEXT_ALIGN_RIGHT, 
                TEXT_ALIGN_BOTTOM
            )
            
            -- 代替弾薬表示
            draw.RoundedBox(8, 437, 0, 75, 53, Color(0, 0, 0, 128))
            draw.SimpleText(
                "ALT", 
                "HudSelectionText", 
                440, 45, 
                Color(255, 250, 0, 255), 
                TEXT_ALIGN_LEFT, 
                TEXT_ALIGN_BOTTOM
            )
            draw.SimpleText(
                values.alt, 
                "vrmod_HalfLife2", 
                512, 50, 
                Color(255, 250, 0, 255), 
                TEXT_ALIGN_RIGHT, 
                TEXT_ALIGN_BOTTOM
            )
            
            -- 武器名表示
            draw.RoundedBox(8, 0, 57, 512, 53, Color(0, 0, 0, 128))
            draw.SimpleText(
                items[values.hoveredItem] and items[values.hoveredItem].title or "", 
                "vrmod_Verdana37", 
                256, 85, 
                Color(255, 250, 0, 255), 
                TEXT_ALIGN_CENTER, 
                TEXT_ALIGN_CENTER
            )
            
            -- 武器スロット表示
            local buttonWidth, buttonHeight = 82, 53
            local gap = (512 - buttonWidth * 6) / 5
            
            for i = 1, #items do
                local x, y = items[i].slot, items[i].actualSlotPos
                
                draw.RoundedBox(
                    8, 
                    x * (buttonWidth + gap), 
                    114 + y * (buttonHeight + gap), 
                    buttonWidth, 
                    buttonHeight, 
                    Color(0, 0, 0, values.hoveredItem == i and 200 or 128)
                )
                
                local explosion = string.Explode(" ", items[i].label, false)
                
                for j = 1, #explosion do
                    draw.SimpleText(
                        explosion[j], 
                        items[i].font, 
                        buttonWidth / 2 + x * (buttonWidth + gap), 
                        114 + buttonHeight / 2 + y * (buttonHeight + gap) - (#explosion * 6 - 6 - (j - 1) * 12), 
                        Color(255, 250, 0, 255), 
                        TEXT_ALIGN_CENTER, 
                        TEXT_ALIGN_CENTER
                    )
                end
            end
            
            VRUtilMenuRenderEnd()
        end)
    end

    -- 武器選択メニューを閉じる
    function VRUtilWeaponMenuClose()
        VRUtilMenuClose("weaponmenu")
    end

-- 